{
  "STATS": {
    "files": 18,
    "imports": 51,
    "exports": 90
  },
  "CODEBASE_ANALYSIS": {
    "analyse": {
      "imports": [
        {
          "moduleSpecifier": "path",
          "kind": "named",
          "namedImports": [
            "join",
            "relative"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "Project"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./analyse.utils",
          "kind": "named",
          "namedImports": [
            "addJSDocToSourceText"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "SRC_DIR"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./exports",
          "kind": "named",
          "namedImports": [
            "analyzeExports"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./helpers",
          "kind": "named",
          "namedImports": [
            "toArray"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./imports",
          "kind": "named",
          "namedImports": [
            "analyzeImports",
            "buildImportStrings"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./schemas",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis"
          ],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "./utils",
          "kind": "named",
          "namedImports": [
            "pathToDotNotation"
          ],
          "isTypeOnly": false
        }
      ],
      "relativePath": "analyse.ts",
      "text": "import { join, relative } from 'path';\nimport { Project } from 'ts-morph';\nimport { addJSDocToSourceText } from './analyse.utils';\nimport { SRC_DIR } from './constants';\nimport { analyzeExports } from './exports';\nimport { toArray } from './helpers';\nimport { analyzeImports, buildImportStrings } from './imports';\nimport type { CodebaseAnalysis } from './schemas';\nimport { pathToDotNotation } from './utils';\n\n/**\n * AnalyzeOptions type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type AnalyzeOptions = {\n  src?: string;\n  excludes?: string | string[];\n};\n\n/**\n * Analyse tous les fichiers TypeScript dans src/ (sauf src/scripts/)\n */\n/**\n * analyze variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const analyze = ({\n  src = SRC_DIR,\n  excludes: _excludes,\n}: AnalyzeOptions = {}): CodebaseAnalysis => {\n  console.log('üîç Analyse du codebase en cours...');\n  const excludes = toArray(_excludes);\n\n  // Initialiser le projet ts-morph\n  const project = new Project({\n    tsConfigFilePath: join(process.cwd(), 'tsconfig.json'),\n  });\n\n  // Ajouter tous les fichiers TypeScript du dossier src\n  const sourceFiles = project.addSourceFilesAtPaths(\n    [\n      'src/**/*.ts',\n      '!src/scripts/**/*', // Exclure le dossier scripts\n      '!src/**/*.test.ts', // Exclure les fichiers de test\n      '!src/**/*.spec.ts', // Exclure les fichiers de spec\n    ].concat(excludes.map(exclude => `!${exclude}`)),\n  );\n\n  const analysis: CodebaseAnalysis = {};\n  let processedCount = 0;\n\n  for (const sourceFile of sourceFiles) {\n    const filePath = sourceFile.getFilePath();\n    const relativePath = relative(src, filePath);\n\n    // G√©n√©rer le texte modifi√© avec JSDoc pour les exports\n\n    const _text = addJSDocToSourceText(sourceFile);\n\n    // #region Analyser les imports et exports\n    const imports = analyzeImports(sourceFile);\n    const exports = analyzeExports(sourceFile);\n    // #endregion\n\n    // Construire les imports √† partir de fileAnalysis.imports\n    const importsStrings = buildImportStrings(imports);\n\n    // Combiner imports et contenu\n    const importsSection =\n      importsStrings.length > 0 ? importsStrings.join('\\n') : '';\n\n    const text =\n      importsSection === ''\n        ? _text\n        : `${importsSection}\n\n${_text}\n    `;\n\n    analysis[pathToDotNotation(relativePath)] = {\n      relativePath,\n      imports,\n      exports,\n      text,\n    };\n\n    processedCount++;\n\n    // #region Afficher l'avancement de l'analyse par palliers de 50\n    if (processedCount % 50 === 0) {\n      console.log(\n        `üìä Analys√© ${processedCount}/${sourceFiles.length} fichiers...`,\n      );\n    }\n    // #endregion\n  }\n\n  console.log(`‚úÖ Analyse termin√©e: ${processedCount} fichiers analys√©s`);\n  return analysis;\n};\n\n    ",
      "exports": []
    },
    "analyse.utils": {
      "imports": [
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "SourceFile"
          ],
          "isTypeOnly": true
        }
      ],
      "relativePath": "analyse.utils.ts",
      "text": "import type { SourceFile } from 'ts-morph';\n\n/**\n * G√©n√®re un JSDoc pour une expression export√©e g√©n√©r√©e automatiquement\n */\n/**\n * generateJSDoc variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const generateJSDoc = (\n  exportName: string,\n  declarationKind?: string,\n): string => {\n  const kindText = declarationKind ? ` ${declarationKind}` : '';\n  return `/**\n * ${exportName}${kindText} - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */`;\n};\n\n/**\n * extractExportDetails variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const extractExportDetails = (trimmedLine: string) => {\n  let exportName = 'export';\n  let declarationKind: string | undefined;\n\n  if (trimmedLine.includes('export default ')) {\n    exportName = 'default';\n    if (trimmedLine.includes('function')) declarationKind = 'function';\n    else if (trimmedLine.includes('class')) declarationKind = 'class';\n    else declarationKind = 'value';\n  } else if (trimmedLine.includes('export const ')) {\n    const match = trimmedLine.match(/export const (\\w+)/);\n    exportName = match ? match[1] : 'const';\n    declarationKind = 'variable';\n  } else if (trimmedLine.includes('export let ')) {\n    const match = trimmedLine.match(/export let (\\w+)/);\n    exportName = match ? match[1] : 'let';\n    declarationKind = 'variable';\n  } else if (trimmedLine.includes('export var ')) {\n    const match = trimmedLine.match(/export var (\\w+)/);\n    exportName = match ? match[1] : 'var';\n    declarationKind = 'variable';\n  } else if (trimmedLine.includes('export function ')) {\n    const match = trimmedLine.match(/export function (\\w+)/);\n    exportName = match ? match[1] : 'function';\n    declarationKind = 'function';\n  } else if (trimmedLine.includes('export class ')) {\n    const match = trimmedLine.match(/export class (\\w+)/);\n    exportName = match ? match[1] : 'class';\n    declarationKind = 'class';\n  } else if (trimmedLine.includes('export interface ')) {\n    const match = trimmedLine.match(/export interface (\\w+)/);\n    exportName = match ? match[1] : 'interface';\n    declarationKind = 'interface';\n  } else if (trimmedLine.includes('export type ')) {\n    const match = trimmedLine.match(/export type (\\w+)/);\n    exportName = match ? match[1] : 'type';\n    declarationKind = 'type';\n  } else if (trimmedLine.includes('export enum ')) {\n    const match = trimmedLine.match(/export enum (\\w+)/);\n    exportName = match ? match[1] : 'enum';\n    declarationKind = 'enum';\n  }\n  return { exportName, declarationKind };\n};\n\n/**\n * V√©rifie si une ligne d'export contient une d√©claration et non pas un simple re-export\n */\n/**\n * hasDeclaration variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const hasDeclaration = (exportLine: string): boolean => {\n  const trimmed = exportLine.trim();\n  const falsy =\n    trimmed.startsWith('export {') || // export { something }\n    trimmed.startsWith('export *') || // export * from\n    trimmed.includes('} from ') || // export { a, b } from\n    trimmed.match(/^export\\s+\\{[^}]*\\}\\s*;?\\s*$/) || // export { a, b };\n    trimmed.match(/^export\\s+default\\s+[a-zA-Z_$][a-zA-Z0-9_$]*\\s*;?\\s*$/); // export default identifier;\n\n  // Re-exports et exports simples √† exclure\n  if (falsy) return false;\n\n  // D√©clarations √† inclure (avec mots-cl√©s de d√©claration)\n  const keywords = [\n    'export const ',\n    'export let ',\n    'export var ',\n    'export function ',\n    'export class ',\n    'export interface ',\n    'export type ',\n    'export enum ',\n    'export namespace ',\n    'export default function ',\n    'export default class ',\n    'export default interface ',\n    'export default enum ',\n    'export default const ',\n    'export default let ',\n    'export default var ',\n  ];\n\n  return keywords.some(kw => trimmed.includes(kw));\n};\n\n/**\n * Extrait le nom d'une d√©claration (const, function, etc.)\n */\n/**\n * extractDeclarationName variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const extractDeclarationName = (line: string): string | null => {\n  const trimmed = line.trim();\n\n  if (trimmed.startsWith('const ')) {\n    const match = trimmed.match(/const\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('function ')) {\n    const match = trimmed.match(/function\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('class ')) {\n    const match = trimmed.match(/class\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('interface ')) {\n    const match = trimmed.match(/interface\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('type ')) {\n    const match = trimmed.match(/type\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('enum ')) {\n    const match = trimmed.match(/enum\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n\n  return null;\n};\n\n/**\n * V√©rifie si une d√©claration est export√©e plus tard dans le fichier\n */\n/**\n * isExportedLater variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const isExportedLater = (\n  lines: string[],\n  declarationName: string,\n): boolean => {\n  return lines.some(line => {\n    const trimmed = line.trim();\n    return (\n      trimmed === `export default ${declarationName};` ||\n      trimmed.includes(`export { ${declarationName}`) ||\n      trimmed.includes(`export * as ${declarationName}`)\n    );\n  });\n};\n\n/**\n * D√©termine le type de d√©claration\n */\n/**\n * getDeclarationKind variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const getDeclarationKind = (line: string): string => {\n  const trimmed = line.trim();\n\n  if (trimmed.startsWith('const ')) return 'const';\n  if (trimmed.startsWith('let ')) return 'let';\n  if (trimmed.startsWith('var ')) return 'var';\n  if (trimmed.startsWith('function ')) return 'function';\n  if (trimmed.startsWith('class ')) return 'class';\n  if (trimmed.startsWith('interface ')) return 'interface';\n  if (trimmed.startsWith('type ')) return 'type';\n  if (trimmed.startsWith('enum ')) return 'enum';\n\n  return 'variable';\n};\n\n/**\n * Ajoute des JSDoc aux expressions export√©es dans le texte source\n */\n/**\n * addJSDocToSourceText variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const addJSDocToSourceText = (sourceFile: SourceFile): string => {\n  // Obtenir le texte sans les imports d√®s le d√©but\n  const fullText = sourceFile.getText();\n  const imports = sourceFile\n    .getImportDeclarations()\n    .map(importDecl => importDecl.getText());\n\n  const linesWithoutImports = fullText\n    .replace(imports.join('\\n'), '')\n    .trimStart();\n\n  let modifiedText = linesWithoutImports;\n\n  // Collecter toutes les positions d'insertion avec leurs JSDoc\n  const insertions: Array<{ position: number; jsdoc: string }> = [];\n\n  // Une approche plus simple : analyser le texte directement pour trouver les exports\n  const lines = modifiedText.split('\\n');\n\n  lines.forEach((line, lineIndex) => {\n    const trimmedLine = line.trim();\n\n    // D√©tecter les lignes qui commencent par export ET contiennent une d√©claration\n    if (trimmedLine.startsWith('export ') && hasDeclaration(trimmedLine)) {\n      // Calculer la position dans le texte original\n      const position =\n        lines.slice(0, lineIndex).join('\\n').length +\n        (lineIndex > 0 ? 1 : 0);\n\n      // D√©terminer le nom et le type d'export\n      const { exportName, declarationKind } =\n        extractExportDetails(trimmedLine);\n\n      const jsdoc = generateJSDoc(exportName, declarationKind);\n      insertions.push({ position, jsdoc: `${jsdoc}\\n` });\n    }\n\n    // D√©tecter les d√©clarations internes (const, function, etc.) qui sont ensuite export√©es\n    if (\n      !trimmedLine.startsWith('export ') &&\n      (trimmedLine.startsWith('const ') ||\n        trimmedLine.startsWith('function ') ||\n        trimmedLine.startsWith('class ') ||\n        trimmedLine.startsWith('interface ') ||\n        trimmedLine.startsWith('type ') ||\n        trimmedLine.startsWith('enum '))\n    ) {\n      // V√©rifier si cette d√©claration est export√©e plus tard dans le fichier\n      const declarationName = extractDeclarationName(trimmedLine);\n      if (declarationName && isExportedLater(lines, declarationName)) {\n        // Calculer la position dans le texte original\n        const position =\n          lines.slice(0, lineIndex).join('\\n').length +\n          (lineIndex > 0 ? 1 : 0);\n\n        const declarationKind = getDeclarationKind(trimmedLine);\n        const jsdoc = generateJSDoc(declarationName, declarationKind);\n        insertions.push({ position, jsdoc: `${jsdoc}\\n` });\n      }\n    }\n  });\n\n  // Trier par position d√©croissante pour ins√©rer de la fin vers le d√©but\n  insertions.sort((a, b) => b.position - a.position);\n\n  // Ins√©rer les JSDoc\n  for (const insertion of insertions) {\n    modifiedText =\n      modifiedText.slice(0, insertion.position) +\n      insertion.jsdoc +\n      modifiedText.slice(insertion.position);\n  }\n\n  return modifiedText;\n};\n\n    ",
      "exports": []
    },
    "cli.cli": {
      "imports": [
        {
          "moduleSpecifier": "cmd-ts",
          "kind": "named",
          "namedImports": [
            "array",
            "command",
            "multioption",
            "option",
            "string"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": [
            "CODEBASE_FILE"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../functions/generate",
          "kind": "named",
          "namedImports": [
            "generate"
          ],
          "isTypeOnly": false
        }
      ],
      "relativePath": "cli/cli.ts",
      "text": "import { array, command, multioption, option, string } from 'cmd-ts';\nimport { CODEBASE_FILE } from '../constants';\nimport { generate } from '../functions/generate';\n\n/**\n * cli variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const cli = command({\n  name: 'generate',\n\n  args: {\n    output: option({\n      long: 'output',\n      short: 'o',\n      type: string,\n      description: 'Output file path',\n      defaultValue: () => CODEBASE_FILE,\n    }),\n    excludes: multioption({\n      description: 'The files to exclude, globs',\n      long: 'excludes',\n      short: 'x',\n      type: array(string),\n      defaultValue: () => [],\n    }),\n  },\n  handler,\n});\n\n    ",
      "exports": []
    },
    "cli.constants": {
      "imports": [],
      "relativePath": "cli/constants.ts",
      "text": "/**\n * BIN variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const BIN = 'codebase';\n",
      "exports": []
    },
    "cli.index": {
      "imports": [
        {
          "moduleSpecifier": "cmd-ts",
          "kind": "named",
          "namedImports": [
            "run"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./cli",
          "kind": "named",
          "namedImports": [
            "cli"
          ],
          "isTypeOnly": false
        }
      ],
      "relativePath": "cli/index.ts",
      "text": "import { run } from 'cmd-ts';\nimport { cli } from './cli';\n\nrun(cli, process.argv.slice(2));\n\n    ",
      "exports": []
    },
    "constants": {
      "imports": [
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "join"
          ],
          "isTypeOnly": false
        }
      ],
      "relativePath": "constants.ts",
      "text": "import { join } from 'node:path';\n\n/**\n * SRC_DIR variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const SRC_DIR = join(process.cwd(), 'src');\n/**\n * CODEBASE_FILE variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const CODEBASE_FILE = join(process.cwd(), '.codebase.json');\n\nconst _REPLACER = '-|||-';\n\n/**\n * REPLACERS variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const REPLACERS = {\n  code: [\n    ['\\\\`', `${_REPLACER}w`],\n    ['`', '\\\\`'],\n    ['${', `$${_REPLACER}{`],\n    ['\\\\s', `${_REPLACER}s`],\n    ['\\\\w', `${_REPLACER}w`],\n  ],\n  init: [\n    [new RegExp('\\\\`', 'g'), '`'],\n    [_REPLACER, ''],\n  ],\n} as const;\n\n/**\n * PATH_KEY variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const PATH_KEY = '#bemedev/*';\n/**\n * JSON_FILE_NAME variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const JSON_FILE_NAME = '.bemedev.json';\n\n/**\n * PATH_PROPERTY variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const PATH_PROPERTY = 'path';\n/**\n * FILES_PROPERTY variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const FILES_PROPERTY = 'files';\n\n/**\n * PROPERTIES variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const PROPERTIES = {\n  PATH: 'path',\n  FILES: 'files',\n  CODEBASE_ANALYSIS: 'CODEBASE_ANALYSIS',\n  STATS: 'STATS',\n} as const;\n\n    ",
      "exports": []
    },
    "exports": {
      "imports": [
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "SourceFile",
            "SyntaxKind"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./schemas",
          "kind": "named",
          "namedImports": [
            "ExportInfo"
          ],
          "isTypeOnly": true
        }
      ],
      "relativePath": "exports.ts",
      "text": "import { SourceFile, SyntaxKind } from 'ts-morph';\nimport type { ExportInfo } from './schemas';\n\n/**\n * analyzeExports variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const analyzeExports = (sourceFile: SourceFile) => {\n  const exports: ExportInfo[] = [];\n\n  // Export declarations (export ...)\n  sourceFile.getExportDeclarations().forEach(exportDecl => {\n    const moduleSpecifier = exportDecl.getModuleSpecifierValue();\n    const exportText = exportDecl.getText();\n\n    // Named exports\n    const namedExports = exportDecl.getNamedExports();\n    namedExports.forEach(namedExport => {\n      exports.push({\n        name: namedExport.getName(),\n        kind: 'named',\n        text: exportText,\n        moduleSpecifier,\n      });\n    });\n\n    // Namespace export (export * from '...')\n    if (exportDecl.isNamespaceExport()) {\n      exports.push({\n        name: '*',\n        kind: 'namespace',\n        text: exportText,\n        moduleSpecifier,\n      });\n    }\n  });\n\n  // Export assignments (export = ...)\n  sourceFile.getExportAssignments().forEach(exportAssignment => {\n    if (exportAssignment.isExportEquals()) {\n      exports.push({\n        name: 'default',\n        kind: 'default',\n        text: exportAssignment.getText(),\n      });\n    }\n  });\n\n  // Exported declarations (export function, export class, etc.)\n  sourceFile.getExportedDeclarations().forEach((declarations, name) => {\n    declarations.forEach(decl => {\n      let declarationKind: ExportInfo['declarationKind'];\n\n      if (decl.getKind() === SyntaxKind.FunctionDeclaration) {\n        declarationKind = 'function';\n      } else if (decl.getKind() === SyntaxKind.ClassDeclaration) {\n        declarationKind = 'class';\n      } else if (decl.getKind() === SyntaxKind.InterfaceDeclaration) {\n        declarationKind = 'interface';\n      } else if (decl.getKind() === SyntaxKind.TypeAliasDeclaration) {\n        declarationKind = 'type';\n      } else if (decl.getKind() === SyntaxKind.VariableDeclaration) {\n        declarationKind = 'variable';\n      } else if (decl.getKind() === SyntaxKind.EnumDeclaration) {\n        declarationKind = 'enum';\n      }\n\n      exports.push({\n        name,\n        kind: name === 'default' ? 'default' : 'named',\n        text: decl.getText(),\n        declarationKind,\n      });\n    });\n  });\n\n  return exports;\n};\n\n    ",
      "exports": []
    },
    "functions.add": {
      "imports": [
        {
          "moduleSpecifier": "edit-json-file",
          "kind": "default",
          "default": "edit",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "edit-json-file",
          "kind": "named",
          "namedImports": [
            "JsonEditor"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "dirname",
            "join",
            "relative",
            "resolve"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": [
            "FILES_PROPERTY",
            "JSON_FILE_NAME",
            "PATH_PROPERTY"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../helpers",
          "kind": "named",
          "namedImports": [
            "consoleStars",
            "getFolderPath",
            "transformModule",
            "writeFileAnalysis"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../schemas",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis",
            "FileAnalysis"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": [
            "NOmit"
          ],
          "isTypeOnly": true
        }
      ],
      "relativePath": "functions/add.ts",
      "text": "import edit from 'edit-json-file';\nimport { JsonEditor } from 'edit-json-file';\nimport { dirname, join, relative, resolve } from 'node:path';\nimport { FILES_PROPERTY, JSON_FILE_NAME, PATH_PROPERTY } from '../constants';\nimport { consoleStars, getFolderPath, transformModule, writeFileAnalysis } from '../helpers';\nimport { CodebaseAnalysis, FileAnalysis } from '../schemas';\nimport type { NOmit } from '../types';\n\nconst processFileAnalysis = (\n  analysis: NOmit<FileAnalysis, 'exports'>,\n  cwd: string,\n  additionals: [string, NOmit<FileAnalysis, 'exports'>][],\n  pathsEntries: [string, NOmit<FileAnalysis, 'exports'>][],\n  files: string[],\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n) => {\n  const relativePath = analysis.relativePath;\n\n  const keys = Object.keys(CODEBASE_ANALYSIS);\n  analysis.imports.forEach(({ moduleSpecifier }) => {\n    const _path = relative(\n      cwd,\n      resolve(dirname(relativePath), moduleSpecifier),\n    ).replaceAll('/', '.');\n\n    const all = additionals\n      .concat(pathsEntries)\n      .map(([key]) => key)\n      .concat(files);\n\n    const canAdd = all.every(p => p !== _path);\n    if (!canAdd) return;\n\n    const toAdd =\n      CODEBASE_ANALYSIS[_path] ?? CODEBASE_ANALYSIS[`${_path}.index`];\n    if (!toAdd) return;\n\n    additionals.push([_path, toAdd]);\n    all.push(_path);\n\n    const imports = toAdd.imports.filter(({ moduleSpecifier }) => {\n      const _path = transformModule({\n        cwd,\n        relativePath: toAdd.relativePath,\n        moduleSpecifier,\n      });\n\n      const array = [_path, `${_path}.index`].filter(p =>\n        keys.includes(p),\n      );\n\n      if (array.length < 1) return false;\n\n      return array.every(p => !all.includes(p));\n    });\n\n    const toAdd2 = { ...toAdd, imports };\n    const canRecurse = toAdd2.imports.length > 0;\n\n    if (canRecurse) {\n      processFileAnalysis(\n        toAdd2,\n        cwd,\n        additionals,\n        pathsEntries,\n        files,\n        CODEBASE_ANALYSIS,\n      );\n    }\n  });\n};\n\n/**\n * add variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const add = (\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n  ...paths: string[]\n) => {\n  const isEmpty = paths.length === 0;\n  if (isEmpty) return console.warn('No files specified for addition.');\n  try {\n    const cwd = process.cwd();\n    const json = join(cwd, JSON_FILE_NAME);\n    let file: JsonEditor | undefined = edit(json);\n\n    if (!file) return;\n\n    const files = file.get(FILES_PROPERTY) as string[];\n    const root = getFolderPath(file.get(PATH_PROPERTY) as string);\n\n    // Release resources\n\n    const additionals: [string, NOmit<FileAnalysis, 'exports'>][] = [];\n\n    const pathsEntries = Object.entries(CODEBASE_ANALYSIS)\n      .filter(([key]) => paths.some(p => key.startsWith(p)))\n      .filter(([key]) => !files.includes(key));\n\n    pathsEntries.forEach(([, analysis]) => {\n      processFileAnalysis(\n        analysis,\n        cwd,\n        additionals,\n        pathsEntries,\n        files,\n        CODEBASE_ANALYSIS,\n      );\n    });\n\n    const entries = new Set(\n      pathsEntries.concat(additionals).filter(([, val]) => !!val),\n    );\n\n    consoleStars();\n    console.log(`üîß Cr√©ation des fichiers (${entries.size} fichiers)...`);\n\n    let success = 0;\n    const length = entries.size;\n\n    entries.forEach(([, fileAnalysis]) => {\n      const _path = writeFileAnalysis(fileAnalysis, root);\n      if (_path) {\n        files.push(_path);\n        file?.set(FILES_PROPERTY, files);\n        success++;\n      }\n    });\n\n    file.save();\n    console.log(`‚úÖ Fichiers cr√©√©s! (${success}/${length})`);\n    file = undefined;\n  } catch {\n    console.error(`‚ùå Erreur lors de la cr√©ation des fichiers`);\n    return false;\n  }\n\n  consoleStars();\n  return true;\n};\n\n    ",
      "exports": []
    },
    "functions.generate": {
      "imports": [
        {
          "moduleSpecifier": "node:fs",
          "kind": "named",
          "namedImports": [
            "writeFileSync"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "relative"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "src/constants",
          "kind": "named",
          "namedImports": [
            "CODEBASE_FILE",
            "SRC_DIR"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../analyse",
          "kind": "named",
          "namedImports": [
            "analyze"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../schemas",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis"
          ],
          "isTypeOnly": false
        }
      ],
      "relativePath": "functions/generate.ts",
      "text": "import { writeFileSync } from 'node:fs';\nimport { relative } from 'node:path';\nimport { CODEBASE_FILE, SRC_DIR } from 'src/constants';\nimport { analyze } from '../analyse';\nimport { CodebaseAnalysis } from '../schemas';\n\n/**\n * transformJSON variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const transformJSON = (data: CodebaseAnalysis) => {\n  let imports = 0;\n  let exports = 0;\n  let files = 0;\n\n  const entries = Object.entries(data).map(\n    ([\n      key,\n      { imports: _imports, relativePath, text, exports: _exports },\n    ]) => {\n      imports += _imports.length;\n      exports += _exports?.length ?? 0;\n      files++;\n\n      const value: any = {\n        imports: _imports,\n        relativePath,\n        text,\n        exports: _exports?.filter(\n          ({ moduleSpecifier }) => moduleSpecifier !== undefined,\n        ),\n      };\n\n      return [key, value] as const;\n    },\n  );\n\n  const CODEBASE_ANALYSIS = Object.fromEntries(entries);\n\n  const STATS = {\n    files,\n    imports,\n    exports,\n  };\n\n  return {\n    STATS,\n    CODEBASE_ANALYSIS,\n  };\n};\n\n/**\n * GenerateOptions type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type GenerateOptions = {\n  output?: string;\n  excludes?: string[] | string;\n  src?: string;\n};\n\n/**\n * Fonction principale d'ex√©cution\n */\n/**\n * generate variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const generate = ({\n  output = CODEBASE_FILE,\n  excludes,\n  src = SRC_DIR,\n}: GenerateOptions = {}) => {\n  const _output = output.endsWith('codebase.json')\n    ? output\n    : `${output}.codebase.json`;\n\n  try {\n    const analysis = analyze({ src, excludes });\n    const transformed = transformJSON(analysis);\n\n    const json = JSON.stringify(transformed, null, 2);\n    writeFileSync(_output, json);\n\n    console.log(\n      `üìÅ Analyse sauvegard√©e dans: ${relative(process.cwd(), _output)}`,\n    );\n    console.log(`üìä Statistiques:`);\n    console.log(`   - Fichiers analys√©s: ${transformed.STATS.files}`);\n    console.log(`   - Total imports: ${transformed.STATS.imports}`);\n    console.log(`   - Total exports: ${transformed.STATS.exports}`);\n  } catch (error) {\n    console.error(\"‚ùå Erreur lors de l'analyse du codebase:\", error);\n    process.exit(1);\n  }\n\n  return true;\n};\n\n    ",
      "exports": []
    },
    "functions.index": {
      "imports": [],
      "relativePath": "functions/index.ts",
      "text": "export * from './add';\nexport * from './generate';\nexport * from './init';\nexport * from './remove';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './add';",
          "moduleSpecifier": "./add"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './generate';",
          "moduleSpecifier": "./generate"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './init';",
          "moduleSpecifier": "./init"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './remove';",
          "moduleSpecifier": "./remove"
        }
      ]
    },
    "functions.init": {
      "imports": [
        {
          "moduleSpecifier": "node:fs",
          "kind": "named",
          "namedImports": [
            "existsSync",
            "mkdirSync",
            "readFileSync",
            "writeFileSync"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "join",
            "relative"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": [
            "PATH_KEY",
            "PROPERTIES"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../helpers",
          "kind": "named",
          "namedImports": [
            "getFolderPath",
            "writeFileAnalysis"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../schemas",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis"
          ],
          "isTypeOnly": false
        }
      ],
      "relativePath": "functions/init.ts",
      "text": "import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport { join, relative } from 'node:path';\nimport { PATH_KEY, PROPERTIES } from '../constants';\nimport { getFolderPath, writeFileAnalysis } from '../helpers';\nimport { CodebaseAnalysis } from '../schemas';\n\n/**\n * InitOptions interface - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport interface InitOptions {\n  /**\n   * Emplacement personnalis√© pour le dossier .bemedev\n   * Par d√©faut: 'src/.bemedev' si src existe, sinon '.bemedev' √† la racine\n   */\n  root: string;\n  json: string;\n}\n\n/**\n * createTypesStructure variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const createTypesStructure = (\n  folderPath: string,\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n) => {\n  const entries = Object.entries(CODEBASE_ANALYSIS).filter(([key]) => {\n    return key.endsWith('types') || key.endsWith('constants');\n  });\n\n  const PATHS: string[] = [];\n\n  console.log(\n    `üîß Cr√©ation de la structure de types (${entries.length} fichiers)...`,\n  );\n\n  for (const [, fileAnalysis] of entries) {\n    const file = writeFileAnalysis(fileAnalysis, folderPath);\n    if (file) PATHS.push(file);\n  }\n\n  console.log(`‚úÖ Structure de types cr√©√©e avec succ√®s!`);\n  return PATHS;\n};\n\n/**\n * init variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const init = (\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n  { root, json }: InitOptions,\n) => {\n  const cwd = process.cwd();\n  const configFile = join(cwd, json);\n  const configExists = existsSync(configFile);\n\n  if (configExists) return true;\n  const folderPath = getFolderPath(root);\n\n  // 1. Cr√©er le dossier\n  try {\n    mkdirSync(folderPath, { recursive: true });\n    console.log(`‚úÖ Dossier .bemedev cr√©√© dans: ${root}`);\n  } catch (error) {\n    console.error(\n      `‚ùå Erreur lors de la cr√©ation du dossier .bemedev:`,\n      error,\n    );\n    return false;\n  }\n\n  let files: string[] = [];\n  // 1.5. Cr√©er la structure des fichiers types\n  try {\n    files = createTypesStructure(folderPath, CODEBASE_ANALYSIS);\n  } catch {\n    console.error(\n      `‚ùå Erreur lors de la cr√©ation de la structure de types:`,\n    );\n    return false;\n  }\n\n  // 2. Mettre √† jour le tsconfig.json\n  const tsconfigPath = join(cwd, 'tsconfig.json');\n\n  if (existsSync(tsconfigPath)) {\n    try {\n      const tsconfigContent = readFileSync(tsconfigPath, 'utf8');\n      const tsconfig = JSON.parse(tsconfigContent);\n\n      // Initialiser compilerOptions et paths si ils n'existent pas\n      if (!tsconfig.compilerOptions) {\n        tsconfig.compilerOptions = {};\n      }\n\n      if (!tsconfig.compilerOptions.paths) {\n        tsconfig.compilerOptions.paths = {};\n      }\n\n      // Ajouter le path #bemedev/*\n      let relativePath = relative(process.cwd(), folderPath);\n      const baseUrl = tsconfig.compilerOptions.baseUrl;\n\n      if (typeof baseUrl === 'string') {\n        // Si baseUrl est d√©fini, calculer le chemin relatif par rapport √† baseUrl\n\n        relativePath = relative(baseUrl, relativePath);\n      } else {\n        // Si baseUrl n'est pas d√©fini, utiliser le chemin absolu\n        tsconfig.compilerOptions.baseUrl = '.';\n      }\n\n      tsconfig.compilerOptions.paths[PATH_KEY] = [`${relativePath}/*`];\n\n      writeFileSync(\n        tsconfigPath,\n        JSON.stringify(tsconfig, null, 2),\n        'utf8',\n      );\n      console.log(`‚úÖ Path #bemedev/* ajout√© au tsconfig.json`);\n    } catch (error) {\n      console.error(\n        `‚ùå Erreur lors de la mise √† jour du tsconfig.json:`,\n        error,\n      );\n      return false;\n    }\n  } else {\n    console.warn(`‚ö†Ô∏è Fichier tsconfig.json introuvable, path non ajout√©`);\n  }\n\n  // 3. Cr√©er le fichier .bemedev.json √† la racine\n\n  const config = {\n    version: '1.0.0',\n    [PROPERTIES.PATH]: root,\n    [PROPERTIES.FILES]: files,\n  };\n\n  try {\n    writeFileSync(configFile, JSON.stringify(config, null, 2), 'utf8');\n    console.log(`‚úÖ Fichier .bemedev.json cr√©√© √† la racine du projet`);\n  } catch (error) {\n    console.error(\n      `‚ùå Erreur lors de la cr√©ation du fichier .bemedev.json:`,\n      error,\n    );\n    return false;\n  }\n\n  console.log(`üéâ Initialisation de bemedev termin√©e avec succ√®s!`);\n  return true;\n};\n\n    ",
      "exports": []
    },
    "functions.remove": {
      "imports": [
        {
          "moduleSpecifier": "edit-json-file",
          "kind": "default",
          "default": "edit",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "edit-json-file",
          "kind": "named",
          "namedImports": [
            "JsonEditor"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "node:fs",
          "kind": "named",
          "namedImports": [
            "unlinkSync"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "join"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": [
            "FILES_PROPERTY",
            "JSON_FILE_NAME",
            "PATH_PROPERTY"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../helpers",
          "kind": "named",
          "namedImports": [
            "consoleStars",
            "getFolderPath",
            "transformModule"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../schemas",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis",
            "FileAnalysis"
          ],
          "isTypeOnly": false
        }
      ],
      "relativePath": "functions/remove.ts",
      "text": "import edit from 'edit-json-file';\nimport { JsonEditor } from 'edit-json-file';\nimport { unlinkSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { FILES_PROPERTY, JSON_FILE_NAME, PATH_PROPERTY } from '../constants';\nimport { consoleStars, getFolderPath, transformModule } from '../helpers';\nimport { CodebaseAnalysis, FileAnalysis } from '../schemas';\n\nconst transformModules = (\n  entries: [string, FileAnalysis][],\n  ...files: string[]\n) => {\n  const cwd = process.cwd();\n  const out = entries\n    .map(\n      ([key, { imports, relativePath }]) =>\n        [key, relativePath, imports] as const,\n    )\n    .map(([key, relativePath, imports]) => {\n      const specifiers = imports\n        .map(({ moduleSpecifier }) => {\n          return transformModule({\n            cwd,\n            relativePath,\n            moduleSpecifier,\n          });\n        })\n        .map(_path => [_path, `${_path}.index`]) // Ajouter les variantes .index\n        .flat()\n        .filter(s => files.includes(s));\n\n      return [key, Array.from(new Set(specifiers))] as const;\n    });\n\n  return out;\n};\n\n/**\n * remove variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const remove = (\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n  ...paths: string[]\n) => {\n  const isEmpty = paths.length === 0;\n  if (isEmpty) return console.warn('No files specified for removal.');\n  try {\n    const cwd = process.cwd();\n    const json = join(cwd, JSON_FILE_NAME);\n    let file: JsonEditor | undefined = edit(json);\n\n    if (!file) return;\n\n    const root = getFolderPath(file.get(PATH_PROPERTY) as string);\n    const files = file.get(FILES_PROPERTY) as string[];\n\n    const entries2 = Object.entries(CODEBASE_ANALYSIS).filter(([key]) =>\n      files.includes(key),\n    );\n\n    const entries = entries2.filter(([key]) =>\n      paths.some(p => key.startsWith(p)),\n    );\n\n    // V√©rifier les d√©pendances avant suppression\n    const safesToRemove: string[] = [];\n    const cannotsRemove: [string, string[]][] = [];\n\n    entries.forEach(([key]) => {\n      const modules = transformModules(entries2, ...files);\n      const importedFroms = modules\n        .filter(([, specifiers]) => specifiers.includes(key))\n        .map(([k]) => k);\n\n      const check = importedFroms.length > 0;\n\n      console.log('modules', '=>', importedFroms);\n      console.log('key', '=>', key);\n\n      if (check) return cannotsRemove.push([key, importedFroms]);\n      return safesToRemove.push(key);\n    });\n\n    consoleStars();\n    console.log(\n      `üîß Suppression des fichiers (${entries.length} fichiers)...`,\n    );\n\n    // Afficher les fichiers qui ne peuvent pas √™tre supprim√©s\n    if (cannotsRemove.length > 0) {\n      const len = cannotsRemove.length;\n      const one =\n        \"fichier ne peut pas √™tre supprim√© (import√© dans d'autres fichiers)\";\n      const many =\n        \"fichiers ne peuvent pas √™tre supprim√©s (import√©s dans d'autres fichiers)\";\n\n      console.warn(`‚ö†Ô∏è  ${len} ${len === 1 ? one : many} :`);\n      cannotsRemove.forEach(([key, modules]) => {\n        console.warn(`  - ‚ö†Ô∏è  ${key} import√© par :`);\n        modules.forEach(m => console.warn(`    -> üìå ${m}`));\n      });\n    }\n\n    if (safesToRemove.length === 0) {\n      console.warn('‚ùå Aucun fichier ne peut √™tre supprim√©.');\n      return consoleStars();\n    }\n\n    const formatteds = safesToRemove.map(key => {\n      const _path = `${key.replaceAll('.', '/')}.ts`;\n      const absolute = join(root, _path);\n      return [key, absolute] as const;\n    });\n\n    console.log(\n      `üóëÔ∏è Suppression des fichiers (${safesToRemove.length} fichiers)...`,\n    );\n\n    let success = 0;\n    const length = formatteds.length;\n\n    formatteds.forEach(([key, path]) => {\n      try {\n        unlinkSync(path);\n        console.log(`  - üóëÔ∏è ${key}`);\n        file?.set(\n          FILES_PROPERTY,\n          files.filter(key1 => key1 !== key),\n        );\n        success++;\n      } catch {\n        console.error(`  - ‚ùå Erreur, ${key} :`);\n      }\n    });\n\n    file.save();\n    console.log(`üóëÔ∏è Fichiers supprim√©s! (${success}/${length})`);\n    file = undefined;\n  } catch {\n    console.error(`‚ùå Erreur lors de la cr√©ation des fichiers`);\n    consoleStars();\n    return false;\n  }\n  consoleStars();\n  return true;\n};\n\n    ",
      "exports": []
    },
    "helpers": {
      "imports": [
        {
          "moduleSpecifier": "node:fs",
          "kind": "named",
          "namedImports": [
            "existsSync",
            "mkdirSync",
            "writeFileSync"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "dirname",
            "join",
            "relative",
            "resolve"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "REPLACERS"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./schemas",
          "kind": "named",
          "namedImports": [
            "FileAnalysis"
          ],
          "isTypeOnly": false
        }
      ],
      "relativePath": "helpers.ts",
      "text": "import { existsSync, mkdirSync, writeFileSync } from 'node:fs';\nimport { dirname, join, relative, resolve } from 'node:path';\nimport { REPLACERS } from './constants';\nimport { FileAnalysis } from './schemas';\n\n/**\n * TransformModuleArgs type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type TransformModuleArgs = {\n  cwd?: string;\n  relativePath: string;\n  moduleSpecifier: string;\n};\n\n/**\n * transformModule variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const transformModule = ({\n  cwd = process.cwd(),\n  relativePath,\n  moduleSpecifier,\n}: TransformModuleArgs) => {\n  const out = relative(\n    cwd,\n    resolve(dirname(relativePath), moduleSpecifier),\n  ).replaceAll('/', '.');\n\n  return out;\n};\n\n/**\n * writeFileAnalysis variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const writeFileAnalysis = (\n  fileAnalysis: FileAnalysis,\n  folderPath: string,\n) => {\n  const relativePath = fileAnalysis.relativePath;\n\n  // Cr√©er le chemin de destination dans .bemedev en maintenant la structure\n  const destPath = join(folderPath, relativePath);\n  const destDir = dirname(destPath);\n\n  try {\n    // Cr√©er le dossier de destination si n√©cessaire\n    mkdirSync(destDir, { recursive: true });\n\n    let fileContent = fileAnalysis.text;\n    REPLACERS.init.forEach(([search, replace]) => {\n      fileContent = fileContent.replaceAll(search, replace);\n    });\n\n    // √âcrire le contenu du fichier types\n    writeFileSync(destPath, fileContent, 'utf8');\n\n    console.log(`  ‚úÖ ${relativePath}`);\n    return relativePath.slice(0, -3).replaceAll('/', '.');\n  } catch (error) {\n    return console.error(`  ‚ùå Erreur pour ${relativePath}:`, error);\n  }\n};\n\n/**\n * consoleStars variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const consoleStars = () => {\n  console.log();\n  console.log('*'.repeat(30));\n  console.log();\n};\n\n/**\n * toArray variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const toArray = <T>(value?: T | T[]): T[] => {\n  return Array.isArray(value) ? value : !value ? [] : [value];\n};\n\n/**\n * getFolderPath variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const getFolderPath = (root: string) => {\n  const cwd = process.cwd();\n  const srcExists = existsSync(join(cwd, 'src'));\n  const folderPath = srcExists ? join(cwd, 'src', root) : join(cwd, root);\n\n  return folderPath;\n};\n\n    ",
      "exports": []
    },
    "imports": {
      "imports": [
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "join",
            "relative"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "SourceFile",
            "SyntaxKind"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./schemas",
          "kind": "named",
          "namedImports": [
            "ImportInfo"
          ],
          "isTypeOnly": true
        }
      ],
      "relativePath": "imports.ts",
      "text": "import { join, relative } from 'node:path';\nimport { SourceFile, SyntaxKind } from 'ts-morph';\nimport type { ImportInfo } from './schemas';\n\n/**\n * R√©sout le moduleSpecifier en utilisant les paths du tsconfig si il commence par \"#\"\n */\nconst resolveModuleSpecifier = (\n  sourceFile: SourceFile,\n  moduleSpecifier: string,\n): string => {\n  const paths = sourceFile.getProject().getCompilerOptions().paths;\n\n  if (!paths) return moduleSpecifier;\n\n  const baseUrl = sourceFile.getProject().getCompilerOptions().baseUrl;\n  const paths2 = Object.entries(paths);\n\n  // Chercher la correspondance dans les paths\n  for (const [pattern, mappings] of paths2) {\n    // Remplacer * par une regex pour matcher\n    const regexPattern = pattern.replace(/\\*/g, '(.*)');\n    const regex = new RegExp(`^${regexPattern}$`);\n    const match = moduleSpecifier.match(regex);\n\n    if (match) {\n      // Prendre le premier mapping disponible\n      const first = mappings[0];\n\n      // R√©soudre le chemin absolu\n      let relativedPath = baseUrl ? join(baseUrl, first) : first;\n\n      if (match[1]) {\n        relativedPath = relativedPath.replace('*', match[1]);\n      }\n\n      // Calculer le chemin relatif depuis le fichier source actuel\n      const sourceFileDir = relative(\n        process.cwd(),\n        sourceFile.getDirectoryPath(),\n      );\n      const relativePath = relative(sourceFileDir, relativedPath);\n\n      // S'assurer que le chemin relatif commence par ./ ou ../\n      return relativePath.startsWith('.')\n        ? relativePath\n        : `./${relativePath}`;\n    }\n  }\n\n  return moduleSpecifier;\n};\n\n/**\n * Analyse les imports d'un fichier\n */\n/**\n * analyzeImports variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const analyzeImports = (sourceFile: SourceFile): ImportInfo[] => {\n  const imports: ImportInfo[] = [];\n\n  // Import declarations (import ... from '...')\n  sourceFile.getImportDeclarations().forEach(importDecl => {\n    // Determine if this is a type-only import\n    const isTypeOnly = importDecl.isTypeOnly();\n\n    const rawModuleSpecifier = importDecl.getModuleSpecifierValue();\n    const moduleSpecifier = resolveModuleSpecifier(\n      sourceFile,\n      rawModuleSpecifier,\n    );\n\n    // Import default\n    const defaultImport = importDecl.getDefaultImport();\n    if (defaultImport) {\n      imports.push({\n        moduleSpecifier,\n        kind: 'default',\n        default: defaultImport.getText(),\n        isTypeOnly,\n      });\n    }\n\n    // Import namespace (* as name)\n    const namespaceImport = importDecl.getNamespaceImport();\n    if (namespaceImport) {\n      imports.push({\n        moduleSpecifier,\n        kind: 'namespace',\n        default: namespaceImport.getText(),\n        isTypeOnly,\n      });\n    }\n\n    // Named imports ({ name1, name2 })\n    const namedImports = importDecl.getNamedImports();\n    if (namedImports.length > 0) {\n      imports.push({\n        moduleSpecifier,\n        kind: 'named',\n        namedImports: namedImports.map(ni => ni.getName()),\n        isTypeOnly,\n      });\n    }\n\n    // Side-effect import (import '...')\n    if (!defaultImport && !namespaceImport && namedImports.length === 0) {\n      imports.push({\n        moduleSpecifier,\n        kind: 'side-effect',\n        isTypeOnly,\n      });\n    }\n  });\n\n  // Dynamic imports (import('...'))\n  sourceFile\n    .getDescendantsOfKind(SyntaxKind.CallExpression)\n    .forEach(callExpr => {\n      if (\n        callExpr.getExpression().getKind() === SyntaxKind.ImportKeyword\n      ) {\n        const arg = callExpr.getArguments()[0];\n        if (arg && arg.getKind() === SyntaxKind.StringLiteral) {\n          const rawModuleSpecifier = arg.getText().replace(/['\"]/g, '');\n          const moduleSpecifier = resolveModuleSpecifier(\n            sourceFile,\n            rawModuleSpecifier,\n          );\n          imports.push({\n            moduleSpecifier,\n            kind: 'side-effect',\n            isDynamic: true,\n          });\n        }\n      }\n    });\n\n  return imports;\n};\n\n/**\n * buildImportStrings variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const buildImportStrings = (imports: ImportInfo[]) => {\n  return imports.map(imp => {\n    switch (imp.kind) {\n      case 'named': {\n        const namedImports = imp.namedImports?.join(', ') || '';\n        return `import ${imp.isTypeOnly ? 'type ' : ''}{ ${namedImports} } from '${imp.moduleSpecifier}';`;\n      }\n      case 'namespace':\n        return `import ${imp.isTypeOnly ? 'type ' : ''}* as ${imp.default} from '${imp.moduleSpecifier}';`;\n      case 'side-effect': {\n        if (imp.isDynamic) {\n          return `// Dynamic import: import('${imp.moduleSpecifier}')`;\n        }\n        return `import '${imp.moduleSpecifier}';`;\n      }\n\n      case 'default':\n        return `import ${imp.isTypeOnly ? 'type ' : ''}${imp.default} from '${imp.moduleSpecifier}';`;\n      default:\n        return '';\n    }\n  });\n};\n\n    ",
      "exports": []
    },
    "index": {
      "imports": [],
      "relativePath": "index.ts",
      "text": "export * from './functions';\nexport * from './schemas';\nexport * from './types';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './functions';",
          "moduleSpecifier": "./functions"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './schemas';",
          "moduleSpecifier": "./schemas"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './types';",
          "moduleSpecifier": "./types"
        }
      ]
    },
    "schemas": {
      "imports": [
        {
          "moduleSpecifier": "valibot",
          "kind": "namespace",
          "default": "v",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "PROPERTIES"
          ],
          "isTypeOnly": false
        }
      ],
      "relativePath": "schemas.ts",
      "text": "import * as v from 'valibot';\nimport { PROPERTIES } from './constants';\n\n/**\n * DeclarationKindSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const DeclarationKindSchema = v.picklist([\n  'function',\n  'class',\n  'interface',\n  'type',\n  'variable',\n  'const',\n  'let',\n  'enum',\n]);\n\n/**\n * ImportInfoSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const ImportInfoSchema = v.object({\n  moduleSpecifier: v.string(),\n  kind: v.picklist(['default', 'named', 'namespace', 'side-effect']),\n  namedImports: v.optional(v.array(v.string())),\n  default: v.optional(v.string()),\n  isDynamic: v.optional(v.boolean()),\n  isTypeOnly: v.optional(v.boolean()),\n});\n\n/**\n * ExportInfoSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const ExportInfoSchema = v.object({\n  name: v.string(),\n  kind: v.picklist(['default', 'named', 'namespace']),\n  text: v.optional(v.string()),\n  moduleSpecifier: v.optional(v.string()),\n  declarationKind: v.optional(DeclarationKindSchema),\n});\n\n/**\n * FileAnalysisSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const FileAnalysisSchema = v.object({\n  relativePath: v.string(),\n  imports: v.array(ImportInfoSchema),\n  exports: v.optional(v.array(ExportInfoSchema)),\n  text: v.string(),\n});\n\n// Schema pour CodebaseAnalysis\n/**\n * CodebaseAnalysisSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const CodebaseAnalysisSchema = v.record(\n  v.string(),\n  FileAnalysisSchema,\n);\n\n// Schema pour les statistiques d'analyse\n/**\n * AnalysisStatsSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const AnalysisStatsSchema = v.object({\n  files: v.number(),\n  imports: v.number(),\n  exports: v.number(),\n});\n\n// Schema complet pour un fichier .code contenant l'analyse compl√®te\n/**\n * CodeAnalysisFileSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const CodeAnalysisFileSchema = v.object({\n  [PROPERTIES.CODEBASE_ANALYSIS]: CodebaseAnalysisSchema,\n  [PROPERTIES.STATS]: v.optional(AnalysisStatsSchema),\n});\n\n// Types inf√©r√©s des sch√©mas\n/**\n * DeclarationKind type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeclarationKind = v.InferOutput<typeof DeclarationKindSchema>;\n/**\n * ImportInfo type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ImportInfo = v.InferOutput<typeof ImportInfoSchema>;\n/**\n * ExportInfo type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ExportInfo = v.InferOutput<typeof ExportInfoSchema>;\n/**\n * FileAnalysis type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type FileAnalysis = v.InferOutput<typeof FileAnalysisSchema>;\n/**\n * CodebaseAnalysis type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type CodebaseAnalysis = v.InferOutput<\n  typeof CodebaseAnalysisSchema\n>;\n/**\n * AnalysisStats type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type AnalysisStats = v.InferOutput<typeof AnalysisStatsSchema>;\n/**\n * CodeAnalysisFile type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type CodeAnalysisFile = v.InferOutput<\n  typeof CodeAnalysisFileSchema\n>;\n\n    ",
      "exports": []
    },
    "types": {
      "imports": [],
      "relativePath": "types.ts",
      "text": "/**\n * NOmit type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NOmit<T, K extends keyof T> = Omit<T, K>;\n",
      "exports": []
    },
    "utils": {
      "imports": [],
      "relativePath": "utils.ts",
      "text": "/**\n * pathToDotNotation function - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport function pathToDotNotation(filePath: string): string {\n  return filePath\n    .replace(/\\.ts$/, '') // Enlever l'extension .ts\n    .replace(/\\//g, '.'); // Remplacer les / par des .\n}\n",
      "exports": []
    }
  }
}