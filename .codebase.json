{
  "STATS": {
    "files": 18,
    "imports": 51,
    "exports": 77
  },
  "CODEBASE_ANALYSIS": {
    "analyse": {
      "imports": [
        {
          "moduleSpecifier": "path",
          "kind": "named",
          "namedImports": [
            "join",
            "relative"
          ]
        },
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "Project"
          ]
        },
        {
          "moduleSpecifier": "./analyse.utils",
          "kind": "named",
          "namedImports": [
            "addJSDocToSourceText"
          ]
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "SRC_DIR"
          ]
        },
        {
          "moduleSpecifier": "./exports",
          "kind": "named",
          "namedImports": [
            "analyzeExports"
          ]
        },
        {
          "moduleSpecifier": "./helpers",
          "kind": "named",
          "namedImports": [
            "toArray"
          ]
        },
        {
          "moduleSpecifier": "./imports",
          "kind": "named",
          "namedImports": [
            "analyzeImports",
            "buildImportStrings"
          ]
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis"
          ]
        },
        {
          "moduleSpecifier": "./utils",
          "kind": "named",
          "namedImports": [
            "pathToDotNotation"
          ]
        }
      ],
      "relativePath": "analyse.ts",
      "text": "import { join, relative } from 'path';\nimport { Project } from 'ts-morph';\nimport { addJSDocToSourceText } from './analyse.utils';\nimport { SRC_DIR } from './constants';\nimport { analyzeExports } from './exports';\nimport { toArray } from './helpers';\nimport { analyzeImports, buildImportStrings } from './imports';\nimport { CodebaseAnalysis } from './types';\nimport { pathToDotNotation } from './utils';\n\n/**\n * AnalyzeOptions type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type AnalyzeOptions = {\n  src?: string;\n  excludes?: string | string[];\n};\n\n/**\n * Analyse tous les fichiers TypeScript dans src/ (sauf src/scripts/)\n */\n/**\n * analyze variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const analyze = ({\n  src = SRC_DIR,\n  excludes: _excludes,\n}: AnalyzeOptions = {}): CodebaseAnalysis => {\n  console.log('🔍 Analyse du codebase en cours...');\n  const excludes = toArray(_excludes);\n\n  // Initialiser le projet ts-morph\n  const project = new Project({\n    tsConfigFilePath: join(process.cwd(), 'tsconfig.json'),\n  });\n\n  // Ajouter tous les fichiers TypeScript du dossier src\n  const sourceFiles = project.addSourceFilesAtPaths(\n    [\n      'src/**/*.ts',\n      '!src/scripts/**/*', // Exclure le dossier scripts\n      '!src/**/*.test.ts', // Exclure les fichiers de test\n      '!src/**/*.spec.ts', // Exclure les fichiers de spec\n    ].concat(excludes.map(exclude => `!${exclude}`)),\n  );\n\n  const analysis: CodebaseAnalysis = {};\n  let processedCount = 0;\n\n  for (const sourceFile of sourceFiles) {\n    const filePath = sourceFile.getFilePath();\n    const relativePath = relative(src, filePath);\n\n    // Générer le texte modifié avec JSDoc pour les exports\n\n    const _text = addJSDocToSourceText(sourceFile);\n\n    // #region Analyser les imports et exports\n    const imports = analyzeImports(sourceFile);\n    const exports = analyzeExports(sourceFile);\n    // #endregion\n\n    // Construire les imports à partir de fileAnalysis.imports\n    const importsStrings = buildImportStrings(imports);\n\n    // Combiner imports et contenu\n    const importsSection =\n      importsStrings.length > 0 ? importsStrings.join('\\n') : '';\n\n    const text =\n      importsSection === ''\n        ? _text\n        : `${importsSection}\n\n${_text}\n    `;\n\n    analysis[pathToDotNotation(relativePath)] = {\n      relativePath,\n      imports,\n      exports,\n      text,\n    };\n\n    processedCount++;\n\n    // #region Afficher l'avancement de l'analyse par palliers de 50\n    if (processedCount % 50 === 0) {\n      console.log(\n        `📊 Analysé ${processedCount}/${sourceFiles.length} fichiers...`,\n      );\n    }\n    // #endregion\n  }\n\n  console.log(`✅ Analyse terminée: ${processedCount} fichiers analysés`);\n  return analysis;\n};\n\n    "
    },
    "analyse.utils": {
      "imports": [
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "SourceFile"
          ]
        }
      ],
      "relativePath": "analyse.utils.ts",
      "text": "import { SourceFile } from 'ts-morph';\n\n/**\n * Génère un JSDoc pour une expression exportée générée automatiquement\n */\n/**\n * generateJSDoc variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const generateJSDoc = (\n  exportName: string,\n  declarationKind?: string,\n): string => {\n  const kindText = declarationKind ? ` ${declarationKind}` : '';\n  return `/**\n * ${exportName}${kindText} - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */`;\n};\n\n/**\n * extractExportDetails variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const extractExportDetails = (trimmedLine: string) => {\n  let exportName = 'export';\n  let declarationKind: string | undefined;\n\n  if (trimmedLine.includes('export default ')) {\n    exportName = 'default';\n    if (trimmedLine.includes('function')) declarationKind = 'function';\n    else if (trimmedLine.includes('class')) declarationKind = 'class';\n    else declarationKind = 'value';\n  } else if (trimmedLine.includes('export const ')) {\n    const match = trimmedLine.match(/export const (\\w+)/);\n    exportName = match ? match[1] : 'const';\n    declarationKind = 'variable';\n  } else if (trimmedLine.includes('export let ')) {\n    const match = trimmedLine.match(/export let (\\w+)/);\n    exportName = match ? match[1] : 'let';\n    declarationKind = 'variable';\n  } else if (trimmedLine.includes('export var ')) {\n    const match = trimmedLine.match(/export var (\\w+)/);\n    exportName = match ? match[1] : 'var';\n    declarationKind = 'variable';\n  } else if (trimmedLine.includes('export function ')) {\n    const match = trimmedLine.match(/export function (\\w+)/);\n    exportName = match ? match[1] : 'function';\n    declarationKind = 'function';\n  } else if (trimmedLine.includes('export class ')) {\n    const match = trimmedLine.match(/export class (\\w+)/);\n    exportName = match ? match[1] : 'class';\n    declarationKind = 'class';\n  } else if (trimmedLine.includes('export interface ')) {\n    const match = trimmedLine.match(/export interface (\\w+)/);\n    exportName = match ? match[1] : 'interface';\n    declarationKind = 'interface';\n  } else if (trimmedLine.includes('export type ')) {\n    const match = trimmedLine.match(/export type (\\w+)/);\n    exportName = match ? match[1] : 'type';\n    declarationKind = 'type';\n  } else if (trimmedLine.includes('export enum ')) {\n    const match = trimmedLine.match(/export enum (\\w+)/);\n    exportName = match ? match[1] : 'enum';\n    declarationKind = 'enum';\n  }\n  return { exportName, declarationKind };\n};\n\n/**\n * Vérifie si une ligne d'export contient une déclaration et non pas un simple re-export\n */\n/**\n * hasDeclaration variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const hasDeclaration = (exportLine: string): boolean => {\n  const trimmed = exportLine.trim();\n  const falsy =\n    trimmed.startsWith('export {') || // export { something }\n    trimmed.startsWith('export *') || // export * from\n    trimmed.includes('} from ') || // export { a, b } from\n    trimmed.match(/^export\\s+\\{[^}]*\\}\\s*;?\\s*$/) || // export { a, b };\n    trimmed.match(/^export\\s+default\\s+[a-zA-Z_$][a-zA-Z0-9_$]*\\s*;?\\s*$/); // export default identifier;\n\n  // Re-exports et exports simples à exclure\n  if (falsy) return false;\n\n  // Déclarations à inclure (avec mots-clés de déclaration)\n  const keywords = [\n    'export const ',\n    'export let ',\n    'export var ',\n    'export function ',\n    'export class ',\n    'export interface ',\n    'export type ',\n    'export enum ',\n    'export namespace ',\n    'export default function ',\n    'export default class ',\n    'export default interface ',\n    'export default enum ',\n    'export default const ',\n    'export default let ',\n    'export default var ',\n  ];\n\n  return keywords.some(kw => trimmed.includes(kw));\n};\n\n/**\n * Extrait le nom d'une déclaration (const, function, etc.)\n */\n/**\n * extractDeclarationName variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const extractDeclarationName = (line: string): string | null => {\n  const trimmed = line.trim();\n\n  if (trimmed.startsWith('const ')) {\n    const match = trimmed.match(/const\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('function ')) {\n    const match = trimmed.match(/function\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('class ')) {\n    const match = trimmed.match(/class\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('interface ')) {\n    const match = trimmed.match(/interface\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('type ')) {\n    const match = trimmed.match(/type\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('enum ')) {\n    const match = trimmed.match(/enum\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n\n  return null;\n};\n\n/**\n * Vérifie si une déclaration est exportée plus tard dans le fichier\n */\n/**\n * isExportedLater variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const isExportedLater = (\n  lines: string[],\n  declarationName: string,\n): boolean => {\n  return lines.some(line => {\n    const trimmed = line.trim();\n    return (\n      trimmed === `export default ${declarationName};` ||\n      trimmed.includes(`export { ${declarationName}`) ||\n      trimmed.includes(`export * as ${declarationName}`)\n    );\n  });\n};\n\n/**\n * Détermine le type de déclaration\n */\n/**\n * getDeclarationKind variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const getDeclarationKind = (line: string): string => {\n  const trimmed = line.trim();\n\n  if (trimmed.startsWith('const ')) return 'const';\n  if (trimmed.startsWith('let ')) return 'let';\n  if (trimmed.startsWith('var ')) return 'var';\n  if (trimmed.startsWith('function ')) return 'function';\n  if (trimmed.startsWith('class ')) return 'class';\n  if (trimmed.startsWith('interface ')) return 'interface';\n  if (trimmed.startsWith('type ')) return 'type';\n  if (trimmed.startsWith('enum ')) return 'enum';\n\n  return 'variable';\n};\n\n/**\n * Ajoute des JSDoc aux expressions exportées dans le texte source\n */\n/**\n * addJSDocToSourceText variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const addJSDocToSourceText = (sourceFile: SourceFile): string => {\n  // Obtenir le texte sans les imports dès le début\n  const fullText = sourceFile.getText();\n  const imports = sourceFile\n    .getImportDeclarations()\n    .map(importDecl => importDecl.getText());\n\n  const linesWithoutImports = fullText\n    .replace(imports.join('\\n'), '')\n    .trimStart();\n\n  let modifiedText = linesWithoutImports;\n\n  // Collecter toutes les positions d'insertion avec leurs JSDoc\n  const insertions: Array<{ position: number; jsdoc: string }> = [];\n\n  // Une approche plus simple : analyser le texte directement pour trouver les exports\n  const lines = modifiedText.split('\\n');\n\n  lines.forEach((line, lineIndex) => {\n    const trimmedLine = line.trim();\n\n    // Détecter les lignes qui commencent par export ET contiennent une déclaration\n    if (trimmedLine.startsWith('export ') && hasDeclaration(trimmedLine)) {\n      // Calculer la position dans le texte original\n      const position =\n        lines.slice(0, lineIndex).join('\\n').length +\n        (lineIndex > 0 ? 1 : 0);\n\n      // Déterminer le nom et le type d'export\n      const { exportName, declarationKind } =\n        extractExportDetails(trimmedLine);\n\n      const jsdoc = generateJSDoc(exportName, declarationKind);\n      insertions.push({ position, jsdoc: `${jsdoc}\\n` });\n    }\n\n    // Détecter les déclarations internes (const, function, etc.) qui sont ensuite exportées\n    if (\n      !trimmedLine.startsWith('export ') &&\n      (trimmedLine.startsWith('const ') ||\n        trimmedLine.startsWith('function ') ||\n        trimmedLine.startsWith('class ') ||\n        trimmedLine.startsWith('interface ') ||\n        trimmedLine.startsWith('type ') ||\n        trimmedLine.startsWith('enum '))\n    ) {\n      // Vérifier si cette déclaration est exportée plus tard dans le fichier\n      const declarationName = extractDeclarationName(trimmedLine);\n      if (declarationName && isExportedLater(lines, declarationName)) {\n        // Calculer la position dans le texte original\n        const position =\n          lines.slice(0, lineIndex).join('\\n').length +\n          (lineIndex > 0 ? 1 : 0);\n\n        const declarationKind = getDeclarationKind(trimmedLine);\n        const jsdoc = generateJSDoc(declarationName, declarationKind);\n        insertions.push({ position, jsdoc: `${jsdoc}\\n` });\n      }\n    }\n  });\n\n  // Trier par position décroissante pour insérer de la fin vers le début\n  insertions.sort((a, b) => b.position - a.position);\n\n  // Insérer les JSDoc\n  for (const insertion of insertions) {\n    modifiedText =\n      modifiedText.slice(0, insertion.position) +\n      insertion.jsdoc +\n      modifiedText.slice(insertion.position);\n  }\n\n  return modifiedText;\n};\n\n    "
    },
    "constants": {
      "imports": [
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "join"
          ]
        }
      ],
      "relativePath": "constants.ts",
      "text": "import { join } from 'node:path';\n\n/**\n * SRC_DIR variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const SRC_DIR = join(process.cwd(), 'src');\n/**\n * CODEBASE_FILE variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const CODEBASE_FILE = join(process.cwd(), '.codebase.json');\n\nconst _REPLACER = '-|||-';\n\n/**\n * REPLACERS variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const REPLACERS = {\n  code: [\n    ['\\\\`', `${_REPLACER}w`],\n    ['`', '\\\\`'],\n    ['${', `$${_REPLACER}{`],\n    ['\\\\s', `${_REPLACER}s`],\n    ['\\\\w', `${_REPLACER}w`],\n  ],\n  init: [\n    [new RegExp('\\\\`', 'g'), '`'],\n    [_REPLACER, ''],\n  ],\n} as const;\n\n/**\n * PATH_KEY variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const PATH_KEY = '#bemedev/*';\n/**\n * JSON_FILE_NAME variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const JSON_FILE_NAME = '.bemedev.json';\n\n/**\n * PATH_PROPERTY variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const PATH_PROPERTY = 'path';\n/**\n * FILES_PROPERTY variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const FILES_PROPERTY = 'files';\n\n/**\n * PROPERTIES variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const PROPERTIES = {\n  PATH: 'path',\n  FILES: 'files',\n  CODEBASE_ANALYSIS: 'CODEBASE_ANALYSIS',\n  STATS: 'STATS',\n} as const;\n\n    "
    },
    "exports": {
      "imports": [
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "SourceFile",
            "SyntaxKind"
          ]
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": [
            "ExportInfo"
          ]
        }
      ],
      "relativePath": "exports.ts",
      "text": "import { SourceFile, SyntaxKind } from 'ts-morph';\nimport { ExportInfo } from './types';\n\n/**\n * analyzeExports variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const analyzeExports = (sourceFile: SourceFile) => {\n  const exports: ExportInfo[] = [];\n\n  // Export declarations (export ...)\n  sourceFile.getExportDeclarations().forEach(exportDecl => {\n    const moduleSpecifier = exportDecl.getModuleSpecifierValue();\n    const exportText = exportDecl.getText();\n\n    // Named exports\n    const namedExports = exportDecl.getNamedExports();\n    namedExports.forEach(namedExport => {\n      exports.push({\n        name: namedExport.getName(),\n        kind: 'named',\n        text: exportText,\n        moduleSpecifier,\n      });\n    });\n\n    // Namespace export (export * from '...')\n    if (exportDecl.isNamespaceExport()) {\n      exports.push({\n        name: '*',\n        kind: 'namespace',\n        text: exportText,\n        moduleSpecifier,\n      });\n    }\n  });\n\n  // Export assignments (export = ...)\n  sourceFile.getExportAssignments().forEach(exportAssignment => {\n    if (exportAssignment.isExportEquals()) {\n      exports.push({\n        name: 'default',\n        kind: 'default',\n        text: exportAssignment.getText(),\n      });\n    }\n  });\n\n  // Exported declarations (export function, export class, etc.)\n  sourceFile.getExportedDeclarations().forEach((declarations, name) => {\n    declarations.forEach(decl => {\n      let declarationKind: ExportInfo['declarationKind'];\n\n      if (decl.getKind() === SyntaxKind.FunctionDeclaration) {\n        declarationKind = 'function';\n      } else if (decl.getKind() === SyntaxKind.ClassDeclaration) {\n        declarationKind = 'class';\n      } else if (decl.getKind() === SyntaxKind.InterfaceDeclaration) {\n        declarationKind = 'interface';\n      } else if (decl.getKind() === SyntaxKind.TypeAliasDeclaration) {\n        declarationKind = 'type';\n      } else if (decl.getKind() === SyntaxKind.VariableDeclaration) {\n        declarationKind = 'variable';\n      } else if (decl.getKind() === SyntaxKind.EnumDeclaration) {\n        declarationKind = 'enum';\n      }\n\n      exports.push({\n        name,\n        kind: name === 'default' ? 'default' : 'named',\n        text: decl.getText(),\n        declarationKind,\n      });\n    });\n  });\n\n  return exports;\n};\n\n    "
    },
    "helpers": {
      "imports": [
        {
          "moduleSpecifier": "node:fs",
          "kind": "named",
          "namedImports": [
            "mkdirSync",
            "writeFileSync"
          ]
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "dirname",
            "join",
            "relative",
            "resolve"
          ]
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "REPLACERS"
          ]
        },
        {
          "moduleSpecifier": "./schemas",
          "kind": "named",
          "namedImports": [
            "FileAnalysis"
          ]
        }
      ],
      "relativePath": "helpers.ts",
      "text": "import { mkdirSync, writeFileSync } from 'node:fs';\nimport { dirname, join, relative, resolve } from 'node:path';\nimport { REPLACERS } from './constants';\nimport { FileAnalysis } from './schemas';\n\n/**\n * TransformModuleArgs type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type TransformModuleArgs = {\n  cwd?: string;\n  relativePath: string;\n  moduleSpecifier: string;\n};\n\n/**\n * transformModule variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const transformModule = ({\n  cwd = process.cwd(),\n  relativePath,\n  moduleSpecifier,\n}: TransformModuleArgs) => {\n  const out = relative(\n    cwd,\n    resolve(dirname(relativePath), moduleSpecifier),\n  ).replaceAll('/', '.');\n\n  return out;\n};\n\n/**\n * writeFileAnalysis variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const writeFileAnalysis = (\n  fileAnalysis: FileAnalysis,\n  folderPath: string,\n) => {\n  const relativePath = fileAnalysis.relativePath;\n\n  // Créer le chemin de destination dans .bemedev en maintenant la structure\n  const destPath = join(folderPath, relativePath);\n  const destDir = dirname(destPath);\n\n  try {\n    // Créer le dossier de destination si nécessaire\n    mkdirSync(destDir, { recursive: true });\n\n    let fileContent = fileAnalysis.text;\n    REPLACERS.init\n      // .filter(() => false)\n      .forEach(([search, replace]) => {\n        fileContent = fileContent.replaceAll(search, replace);\n      });\n\n    // Écrire le contenu du fichier types\n    writeFileSync(destPath, fileContent, 'utf8');\n\n    console.log(`  ✅ ${relativePath}`);\n    return relativePath.slice(0, -3).replaceAll('/', '.');\n  } catch (error) {\n    return console.error(`  ❌ Erreur pour ${relativePath}:`, error);\n  }\n};\n\n/**\n * consoleStars variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const consoleStars = () => {\n  console.log();\n  console.log('*'.repeat(30));\n  console.log();\n};\n\n/**\n * toArray variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const toArray = <T>(value?: T | T[]): T[] => {\n  return Array.isArray(value) ? value : !value ? [] : [value];\n};\n\n    "
    },
    "imports": {
      "imports": [
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "join",
            "relative"
          ]
        },
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "SourceFile",
            "SyntaxKind"
          ]
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": [
            "ImportInfo"
          ]
        }
      ],
      "relativePath": "imports.ts",
      "text": "import { join, relative } from 'node:path';\nimport { SourceFile, SyntaxKind } from 'ts-morph';\nimport { ImportInfo } from './types';\n\n/**\n * Résout le moduleSpecifier en utilisant les paths du tsconfig si il commence par \"#\"\n */\nconst resolveModuleSpecifier = (\n  sourceFile: SourceFile,\n  moduleSpecifier: string,\n): string => {\n  const paths = sourceFile.getProject().getCompilerOptions().paths;\n\n  if (!paths) return moduleSpecifier;\n\n  const baseUrl = sourceFile.getProject().getCompilerOptions().baseUrl;\n  const paths2 = Object.entries(paths);\n\n  // Chercher la correspondance dans les paths\n  for (const [pattern, mappings] of paths2) {\n    // Remplacer * par une regex pour matcher\n    const regexPattern = pattern.replace(/\\*/g, '(.*)');\n    const regex = new RegExp(`^${regexPattern}$`);\n    const match = moduleSpecifier.match(regex);\n\n    if (match) {\n      // Prendre le premier mapping disponible\n      const first = mappings[0];\n\n      // Résoudre le chemin absolu\n      let relativedPath = baseUrl ? join(baseUrl, first) : first;\n\n      if (match[1]) {\n        relativedPath = relativedPath.replace('*', match[1]);\n      }\n\n      // Calculer le chemin relatif depuis le fichier source actuel\n      const sourceFileDir = relative(\n        process.cwd(),\n        sourceFile.getDirectoryPath(),\n      );\n      const relativePath = relative(sourceFileDir, relativedPath);\n\n      // S'assurer que le chemin relatif commence par ./ ou ../\n      return relativePath.startsWith('.')\n        ? relativePath\n        : `./${relativePath}`;\n    }\n  }\n\n  return moduleSpecifier;\n};\n\n/**\n * Analyse les imports d'un fichier\n */\n/**\n * analyzeImports variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const analyzeImports = (sourceFile: SourceFile): ImportInfo[] => {\n  const imports: ImportInfo[] = [];\n\n  // Import declarations (import ... from '...')\n  sourceFile.getImportDeclarations().forEach(importDecl => {\n    const rawModuleSpecifier = importDecl.getModuleSpecifierValue();\n    const moduleSpecifier = resolveModuleSpecifier(\n      sourceFile,\n      rawModuleSpecifier,\n    );\n\n    // Import default\n    const defaultImport = importDecl.getDefaultImport();\n    if (defaultImport) {\n      imports.push({\n        moduleSpecifier,\n        kind: 'default',\n        default: defaultImport.getText(),\n      });\n    }\n\n    // Import namespace (* as name)\n    const namespaceImport = importDecl.getNamespaceImport();\n    if (namespaceImport) {\n      imports.push({\n        moduleSpecifier,\n        kind: 'namespace',\n        default: namespaceImport.getText(),\n      });\n    }\n\n    // Named imports ({ name1, name2 })\n    const namedImports = importDecl.getNamedImports();\n    if (namedImports.length > 0) {\n      imports.push({\n        moduleSpecifier,\n        kind: 'named',\n        namedImports: namedImports.map(ni => ni.getName()),\n      });\n    }\n\n    // Side-effect import (import '...')\n    if (!defaultImport && !namespaceImport && namedImports.length === 0) {\n      imports.push({\n        moduleSpecifier,\n        kind: 'side-effect',\n      });\n    }\n  });\n\n  // Dynamic imports (import('...'))\n  sourceFile\n    .getDescendantsOfKind(SyntaxKind.CallExpression)\n    .forEach(callExpr => {\n      if (\n        callExpr.getExpression().getKind() === SyntaxKind.ImportKeyword\n      ) {\n        const arg = callExpr.getArguments()[0];\n        if (arg && arg.getKind() === SyntaxKind.StringLiteral) {\n          const rawModuleSpecifier = arg.getText().replace(/['\"]/g, '');\n          const moduleSpecifier = resolveModuleSpecifier(\n            sourceFile,\n            rawModuleSpecifier,\n          );\n          imports.push({\n            moduleSpecifier,\n            kind: 'side-effect',\n            isDynamic: true,\n          });\n        }\n      }\n    });\n\n  return imports;\n};\n\n/**\n * buildImportStrings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const buildImportStrings = (imports: ImportInfo[]) => {\n  return imports.map(imp => {\n    switch (imp.kind) {\n      case 'named': {\n        const namedImports = imp.namedImports?.join(', ') || '';\n        return `import { ${namedImports} } from '${imp.moduleSpecifier}';`;\n      }\n      case 'namespace':\n        return `import * as ${imp.default} from '${imp.moduleSpecifier}';`;\n      case 'side-effect': {\n        if (imp.isDynamic) {\n          return `// Dynamic import: import('${imp.moduleSpecifier}')`;\n        }\n        return `import '${imp.moduleSpecifier}';`;\n      }\n\n      case 'default':\n        return `import ${imp.default} from '${imp.moduleSpecifier}';`;\n      default:\n        return '';\n    }\n  });\n};\n\n    "
    },
    "index": {
      "imports": [],
      "relativePath": "index.ts",
      "text": "export * from './functions';\n"
    },
    "schemas": {
      "imports": [
        {
          "moduleSpecifier": "valibot",
          "kind": "namespace",
          "default": "v"
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "PROPERTIES"
          ]
        }
      ],
      "relativePath": "schemas.ts",
      "text": "import * as v from 'valibot';\nimport { PROPERTIES } from './constants';\n\n// Schema pour DeclarationKind\n/**\n * DeclarationKindSchema variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const DeclarationKindSchema = v.picklist([\n  'function',\n  'class',\n  'interface',\n  'type',\n  'variable',\n  'const',\n  'let',\n  'enum',\n]);\n\n// Schema pour ImportInfo\n/**\n * ImportInfoSchema variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const ImportInfoSchema = v.object({\n  moduleSpecifier: v.string(),\n  kind: v.picklist(['default', 'named', 'namespace', 'side-effect']),\n  namedImports: v.optional(v.array(v.string())),\n  default: v.optional(v.string()),\n  isDynamic: v.optional(v.boolean()),\n});\n\n// Schema pour ExportInfo\n/**\n * ExportInfoSchema variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const ExportInfoSchema = v.object({\n  name: v.string(),\n  kind: v.picklist(['default', 'named', 'namespace']),\n  text: v.optional(v.string()),\n  moduleSpecifier: v.optional(v.string()),\n  declarationKind: v.optional(DeclarationKindSchema),\n});\n\n// Schema pour FileAnalysis\n/**\n * FileAnalysisSchema variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const FileAnalysisSchema = v.object({\n  relativePath: v.string(),\n  imports: v.array(ImportInfoSchema),\n  exports: v.optional(v.array(ExportInfoSchema)),\n  text: v.string(),\n});\n\n// Schema pour CodebaseAnalysis\n/**\n * CodebaseAnalysisSchema variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const CodebaseAnalysisSchema = v.record(\n  v.string(),\n  FileAnalysisSchema,\n);\n\n// Schema pour les statistiques d'analyse\n/**\n * AnalysisStatsSchema variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const AnalysisStatsSchema = v.object({\n  files: v.number(),\n  imports: v.number(),\n  exports: v.number(),\n});\n\n// Schema complet pour un fichier .code contenant l'analyse complète\n/**\n * CodeAnalysisFileSchema variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const CodeAnalysisFileSchema = v.object({\n  [PROPERTIES.CODEBASE_ANALYSIS]: CodebaseAnalysisSchema,\n  [PROPERTIES.STATS]: v.optional(AnalysisStatsSchema),\n});\n\n// Types inférés des schémas\n/**\n * DeclarationKind type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeclarationKind = v.InferOutput<typeof DeclarationKindSchema>;\n/**\n * ImportInfo type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ImportInfo = v.InferOutput<typeof ImportInfoSchema>;\n/**\n * ExportInfo type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ExportInfo = v.InferOutput<typeof ExportInfoSchema>;\n/**\n * FileAnalysis type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type FileAnalysis = v.InferOutput<typeof FileAnalysisSchema>;\n/**\n * CodebaseAnalysis type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type CodebaseAnalysis = v.InferOutput<\n  typeof CodebaseAnalysisSchema\n>;\n/**\n * AnalysisStats type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type AnalysisStats = v.InferOutput<typeof AnalysisStatsSchema>;\n/**\n * CodeAnalysisFile type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type CodeAnalysisFile = v.InferOutput<\n  typeof CodeAnalysisFileSchema\n>;\n\n    "
    },
    "types": {
      "imports": [],
      "relativePath": "types.ts",
      "text": "/**\n * DeclarationKind type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeclarationKind =\n  | 'function'\n  | 'class'\n  | 'interface'\n  | 'type'\n  | 'variable'\n  | 'const'\n  | 'let'\n  | 'enum';\n\n/**\n * ImportInfo type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ImportInfo = {\n  /** Module importé (ex: './utils', 'fs', etc.) */\n  moduleSpecifier: string;\n  /** Type d'import (default, named, namespace, etc.) */\n  kind: 'default' | 'named' | 'namespace' | 'side-effect';\n  /** Noms importés pour les imports named */\n  namedImports?: string[];\n  /** Nom de l'import default ou namespace */\n  default?: string;\n  /** Import dynamique */\n  isDynamic?: boolean;\n};\n\n/**\n * ExportInfo type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ExportInfo = {\n  /** Nom de l'export */\n  name: string;\n  /** Type d'export */\n  kind: 'default' | 'named' | 'namespace';\n  /** Texte complet de l'export */\n  text?: string;\n  /** Si c'est un re-export, le module source */\n  moduleSpecifier?: string;\n  /** Si c'est une déclaration (function, class, etc.) */\n  declarationKind?: DeclarationKind;\n};\n\n/**\n * FileAnalysis type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type FileAnalysis = {\n  /** Chemin relatif du fichier depuis src/ */\n  relativePath: string;\n  /** Liste des imports du fichier */\n  imports: ImportInfo[];\n  /** Liste des exports du fichier */\n  exports: ExportInfo[];\n  text: string;\n};\n\n/**\n * CodebaseAnalysis type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type CodebaseAnalysis = Record<string, FileAnalysis>;\n\n/**\n * NOmit type - Auto-generated expression\n *\n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * @author chlbri (bri_lvi@icloud.com)\n */\n/**\n * NOmit type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NOmit<T, K extends keyof T> = Omit<T, K>;\n"
    },
    "utils": {
      "imports": [],
      "relativePath": "utils.ts",
      "text": "/**\n * pathToDotNotation function - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport function pathToDotNotation(filePath: string): string {\n  return filePath\n    .replace(/\\.ts$/, '') // Enlever l'extension .ts\n    .replace(/\\//g, '.'); // Remplacer les / par des .\n}\n"
    },
    "cli.cli": {
      "imports": [
        {
          "moduleSpecifier": "cmd-ts",
          "kind": "named",
          "namedImports": [
            "array",
            "command",
            "multioption",
            "option",
            "string"
          ]
        },
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": [
            "CODEBASE_FILE"
          ]
        },
        {
          "moduleSpecifier": "../functions/generate",
          "kind": "named",
          "namedImports": [
            "generate"
          ]
        }
      ],
      "relativePath": "cli/cli.ts",
      "text": "import { array, command, multioption, option, string } from 'cmd-ts';\nimport { CODEBASE_FILE } from '../constants';\nimport { generate } from '../functions/generate';\n\n/**\n * cli variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const cli = command({\n  name: 'generate',\n\n  args: {\n    output: option({\n      long: 'output',\n      short: 'o',\n      type: string,\n      description: 'Output file path',\n      defaultValue: () => CODEBASE_FILE,\n    }),\n    excludes: multioption({\n      description: 'The files to exclude, relative to process.cwd()',\n      long: 'excludes',\n      short: 'x',\n      type: array(string),\n      defaultValue: () => [],\n    }),\n  },\n  handler,\n});\n\n    "
    },
    "cli.constants": {
      "imports": [],
      "relativePath": "cli/constants.ts",
      "text": "/**\n * BIN variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const BIN = 'codebase';\n"
    },
    "cli.index": {
      "imports": [
        {
          "moduleSpecifier": "cmd-ts",
          "kind": "named",
          "namedImports": [
            "run"
          ]
        },
        {
          "moduleSpecifier": "./cli",
          "kind": "named",
          "namedImports": [
            "cli"
          ]
        }
      ],
      "relativePath": "cli/index.ts",
      "text": "import { run } from 'cmd-ts';\nimport { cli } from './cli';\n\nrun(cli, process.argv.slice(2));\n\n    "
    },
    "functions.add": {
      "imports": [
        {
          "moduleSpecifier": "edit-json-file",
          "kind": "default",
          "default": "edit"
        },
        {
          "moduleSpecifier": "edit-json-file",
          "kind": "named",
          "namedImports": [
            "JsonEditor"
          ]
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "dirname",
            "join",
            "relative",
            "resolve"
          ]
        },
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": [
            "FILES_PROPERTY",
            "JSON_FILE_NAME",
            "PATH_PROPERTY"
          ]
        },
        {
          "moduleSpecifier": "../helpers",
          "kind": "named",
          "namedImports": [
            "consoleStars",
            "transformModule",
            "writeFileAnalysis"
          ]
        },
        {
          "moduleSpecifier": "../schemas",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis"
          ]
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": [
            "FileAnalysis",
            "NOmit"
          ]
        }
      ],
      "relativePath": "functions/add.ts",
      "text": "import edit from 'edit-json-file';\nimport { JsonEditor } from 'edit-json-file';\nimport { dirname, join, relative, resolve } from 'node:path';\nimport { FILES_PROPERTY, JSON_FILE_NAME, PATH_PROPERTY } from '../constants';\nimport { consoleStars, transformModule, writeFileAnalysis } from '../helpers';\nimport { CodebaseAnalysis } from '../schemas';\nimport { FileAnalysis, NOmit } from '../types';\n\nconst processFileAnalysis = (\n  analysis: NOmit<FileAnalysis, 'exports'>,\n  cwd: string,\n  additionals: [string, NOmit<FileAnalysis, 'exports'>][],\n  pathsEntries: [string, NOmit<FileAnalysis, 'exports'>][],\n  files: string[],\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n) => {\n  const relativePath = analysis.relativePath;\n\n  const keys = Object.keys(CODEBASE_ANALYSIS);\n  analysis.imports.forEach(({ moduleSpecifier }) => {\n    const _path = relative(\n      cwd,\n      resolve(dirname(relativePath), moduleSpecifier),\n    ).replaceAll('/', '.');\n\n    const toAdd =\n      CODEBASE_ANALYSIS[_path] ?? CODEBASE_ANALYSIS[`${_path}.index`];\n    if (!toAdd) return;\n\n    additionals.push([_path, toAdd]);\n\n    const all = additionals\n      .concat(pathsEntries)\n      .map(([key]) => key)\n      .concat(files);\n\n    const imports = toAdd.imports.filter(({ moduleSpecifier }) => {\n      const _path = transformModule({\n        cwd,\n        relativePath: toAdd.relativePath,\n        moduleSpecifier,\n      });\n\n      const array = [_path, `${_path}.index`].filter(p =>\n        keys.includes(p),\n      );\n\n      if (array.length < 1) return false;\n\n      return array.every(p => !all.includes(p));\n    });\n\n    const toAdd2 = { ...toAdd, imports };\n    const canRecurse = toAdd2.imports.length > 0;\n\n    if (canRecurse) {\n      processFileAnalysis(\n        toAdd2,\n        cwd,\n        additionals,\n        pathsEntries,\n        files,\n        CODEBASE_ANALYSIS,\n      );\n    }\n  });\n};\n\n/**\n * add variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const add = (\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n  ...files: string[]\n) => {\n  const isEmpty = files.length === 0;\n  if (isEmpty) return console.warn('No files specified for addition.');\n  try {\n    const cwd = process.cwd();\n    const json = join(cwd, JSON_FILE_NAME);\n    let file: JsonEditor | undefined = edit(json);\n\n    if (!file) return;\n\n    const path = file.get(PATH_PROPERTY) as string;\n    const files = file.get(FILES_PROPERTY) as string[];\n\n    // Release resources\n\n    const additionals: [string, NOmit<FileAnalysis, 'exports'>][] = [];\n\n    const pathsEntries = Object.entries(CODEBASE_ANALYSIS)\n      .filter(([key]) => files.some(p => key.startsWith(p)))\n      .filter(([key]) => !files.includes(key));\n\n    pathsEntries.forEach(([, analysis]) => {\n      processFileAnalysis(\n        analysis,\n        cwd,\n        additionals,\n        pathsEntries,\n        files,\n        CODEBASE_ANALYSIS,\n      );\n    });\n\n    const entries = new Set(\n      pathsEntries.concat(additionals).filter(([, val]) => !!val),\n    );\n\n    consoleStars();\n    console.log(`🔧 Création des fichiers (${entries.size} fichiers)...`);\n\n    let success = 0;\n    const length = entries.size;\n\n    entries.forEach(([, fileAnalysis]) => {\n      const _path = writeFileAnalysis(fileAnalysis, path);\n      if (_path) {\n        files.push(_path);\n        file?.set(FILES_PROPERTY, files);\n        success++;\n      }\n    });\n\n    file.save();\n    console.log(`✅ Fichiers créés! (${success}/${length})`);\n    file = undefined;\n  } catch {\n    console.error(`❌ Erreur lors de la création des fichiers`);\n    return false;\n  }\n\n  consoleStars();\n  return true;\n};\n\n    "
    },
    "functions.generate": {
      "imports": [
        {
          "moduleSpecifier": "node:fs",
          "kind": "named",
          "namedImports": [
            "writeFileSync"
          ]
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "relative"
          ]
        },
        {
          "moduleSpecifier": "src/constants",
          "kind": "named",
          "namedImports": [
            "CODEBASE_FILE",
            "SRC_DIR"
          ]
        },
        {
          "moduleSpecifier": "../analyse",
          "kind": "named",
          "namedImports": [
            "analyze"
          ]
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis"
          ]
        }
      ],
      "relativePath": "functions/generate.ts",
      "text": "import { writeFileSync } from 'node:fs';\nimport { relative } from 'node:path';\nimport { CODEBASE_FILE, SRC_DIR } from 'src/constants';\nimport { analyze } from '../analyse';\nimport { CodebaseAnalysis } from '../types';\n\n/**\n * transformJSON variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const transformJSON = (data: CodebaseAnalysis) => {\n  let imports = 0;\n  let exports = 0;\n  let files = 0;\n\n  const entries = Object.entries(data).map(\n    ([\n      key,\n      { imports: _imports, relativePath, text, exports: _exports },\n    ]) => {\n      imports += _imports.length;\n      exports += _exports.length;\n      files++;\n\n      const value = {\n        imports: _imports,\n        relativePath,\n        text,\n      };\n      return [key, value] as const;\n    },\n  );\n\n  const CODEBASE_ANALYSIS = Object.fromEntries(entries);\n\n  const STATS = {\n    files,\n    imports,\n    exports,\n  };\n\n  return {\n    STATS,\n    CODEBASE_ANALYSIS,\n  };\n};\n\n/**\n * GenerateOptions type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type GenerateOptions = {\n  output?: string;\n  excludes?: string[] | string;\n  src?: string;\n};\n\n/**\n * Fonction principale d'exécution\n */\n/**\n * generate variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const generate = ({\n  output = CODEBASE_FILE,\n  excludes,\n  src = SRC_DIR,\n}: GenerateOptions = {}) => {\n  const _output = output.endsWith('codebase.json')\n    ? output\n    : `${output}.codebase.json`;\n\n  try {\n    const analysis = analyze({ src, excludes });\n    const transformed = transformJSON(analysis);\n\n    const json = JSON.stringify(transformed, null, 2);\n    writeFileSync(_output, json);\n\n    console.log(\n      `📁 Analyse sauvegardée dans: ${relative(process.cwd(), _output)}`,\n    );\n    console.log(`📊 Statistiques:`);\n    console.log(`   - Fichiers analysés: ${transformed.STATS.files}`);\n    console.log(`   - Total imports: ${transformed.STATS.imports}`);\n    console.log(`   - Total exports: ${transformed.STATS.exports}`);\n  } catch (error) {\n    console.error(\"❌ Erreur lors de l'analyse du codebase:\", error);\n    process.exit(1);\n  }\n\n  return true;\n};\n\n    "
    },
    "functions.index": {
      "imports": [],
      "relativePath": "functions/index.ts",
      "text": "export * from './add';\nexport * from './generate';\nexport * from './init';\nexport * from './remove';\n"
    },
    "functions.init": {
      "imports": [
        {
          "moduleSpecifier": "node:fs",
          "kind": "named",
          "namedImports": [
            "existsSync",
            "mkdirSync",
            "readFileSync",
            "writeFileSync"
          ]
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "join"
          ]
        },
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": [
            "PATH_KEY",
            "PROPERTIES"
          ]
        },
        {
          "moduleSpecifier": "../helpers",
          "kind": "named",
          "namedImports": [
            "writeFileAnalysis"
          ]
        },
        {
          "moduleSpecifier": "../schemas",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis"
          ]
        }
      ],
      "relativePath": "functions/init.ts",
      "text": "import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { PATH_KEY, PROPERTIES } from '../constants';\nimport { writeFileAnalysis } from '../helpers';\nimport { CodebaseAnalysis } from '../schemas';\n\n/**\n * InitOptions interface - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport interface InitOptions {\n  /**\n   * Emplacement personnalisé pour le dossier .bemedev\n   * Par défaut: 'src/.bemedev' si src existe, sinon '.bemedev' à la racine\n   */\n  root: string;\n  json: string;\n}\n\n/**\n * createTypesStructure variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const createTypesStructure = (\n  folderPath: string,\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n) => {\n  const entries = Object.entries(CODEBASE_ANALYSIS).filter(([key]) => {\n    return key.endsWith('types') || key.endsWith('constants');\n  });\n\n  const PATHS: string[] = [];\n\n  console.log(\n    `🔧 Création de la structure de types (${entries.length} fichiers)...`,\n  );\n\n  for (const [, fileAnalysis] of entries) {\n    const file = writeFileAnalysis(fileAnalysis, folderPath);\n    if (file) PATHS.push(file);\n  }\n\n  console.log(`✅ Structure de types créée avec succès!`);\n  return PATHS;\n};\n\n/**\n * init variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const init = (\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n  { root, json }: InitOptions,\n) => {\n  const cwd = process.cwd();\n  const configFile = join(cwd, json);\n  const configExists = existsSync(configFile);\n\n  if (configExists) return true;\n  const srcExists = existsSync(join(cwd, 'src'));\n  const folderPath = srcExists ? join(cwd, 'src', root) : join(cwd, root);\n\n  // 1. Créer le dossier\n  try {\n    mkdirSync(folderPath, { recursive: true });\n    console.log(`✅ Dossier .bemedev créé dans: ${root}`);\n  } catch (error) {\n    console.error(\n      `❌ Erreur lors de la création du dossier .bemedev:`,\n      error,\n    );\n    return false;\n  }\n\n  let files: string[] = [];\n  // 1.5. Créer la structure des fichiers types\n  try {\n    files = createTypesStructure(folderPath, CODEBASE_ANALYSIS);\n  } catch {\n    console.error(\n      `❌ Erreur lors de la création de la structure de types:`,\n    );\n    return false;\n  }\n\n  // 2. Mettre à jour le tsconfig.json\n  const tsconfigPath = join(cwd, 'tsconfig.json');\n\n  if (existsSync(tsconfigPath)) {\n    try {\n      const tsconfigContent = readFileSync(tsconfigPath, 'utf8');\n      const tsconfig = JSON.parse(tsconfigContent);\n\n      // Initialiser compilerOptions et paths si ils n'existent pas\n      if (!tsconfig.compilerOptions) {\n        tsconfig.compilerOptions = {};\n      }\n\n      if (!tsconfig.compilerOptions.paths) {\n        tsconfig.compilerOptions.paths = {};\n      }\n\n      // Ajouter le path #bemedev/*\n      let relativePath = root;\n      const baseUrl = tsconfig.compilerOptions.baseUrl;\n\n      if (typeof baseUrl === 'string') {\n        // Si baseUrl est défini, calculer le chemin relatif par rapport à baseUrl\n\n        relativePath = join(baseUrl, relativePath);\n      } else {\n        // Si baseUrl n'est pas défini, utiliser le chemin absolu\n        tsconfig.compilerOptions.baseUrl = '.';\n      }\n\n      tsconfig.compilerOptions.paths[PATH_KEY] = [`${relativePath}/*`];\n\n      writeFileSync(\n        tsconfigPath,\n        JSON.stringify(tsconfig, null, 2),\n        'utf8',\n      );\n      console.log(`✅ Path #bemedev/* ajouté au tsconfig.json`);\n    } catch (error) {\n      console.error(\n        `❌ Erreur lors de la mise à jour du tsconfig.json:`,\n        error,\n      );\n      return false;\n    }\n  } else {\n    console.warn(`⚠️ Fichier tsconfig.json introuvable, path non ajouté`);\n  }\n\n  // 3. Créer le fichier .bemedev.json à la racine\n\n  const config = {\n    version: '1.0.0',\n    [PROPERTIES.PATH]: root,\n    [PROPERTIES.FILES]: files,\n  };\n\n  try {\n    writeFileSync(configFile, JSON.stringify(config, null, 2), 'utf8');\n    console.log(`✅ Fichier .bemedev.json créé à la racine du projet`);\n  } catch (error) {\n    console.error(\n      `❌ Erreur lors de la création du fichier .bemedev.json:`,\n      error,\n    );\n    return false;\n  }\n\n  console.log(`🎉 Initialisation de bemedev terminée avec succès!`);\n  return true;\n};\n\n    "
    },
    "functions.remove": {
      "imports": [
        {
          "moduleSpecifier": "edit-json-file",
          "kind": "default",
          "default": "edit"
        },
        {
          "moduleSpecifier": "edit-json-file",
          "kind": "named",
          "namedImports": [
            "JsonEditor"
          ]
        },
        {
          "moduleSpecifier": "node:fs",
          "kind": "named",
          "namedImports": [
            "unlinkSync"
          ]
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "join"
          ]
        },
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": [
            "FILES_PROPERTY",
            "JSON_FILE_NAME",
            "PATH_PROPERTY"
          ]
        },
        {
          "moduleSpecifier": "../helpers",
          "kind": "named",
          "namedImports": [
            "consoleStars",
            "transformModule"
          ]
        },
        {
          "moduleSpecifier": "../schemas",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis",
            "FileAnalysis"
          ]
        }
      ],
      "relativePath": "functions/remove.ts",
      "text": "import edit from 'edit-json-file';\nimport { JsonEditor } from 'edit-json-file';\nimport { unlinkSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { FILES_PROPERTY, JSON_FILE_NAME, PATH_PROPERTY } from '../constants';\nimport { consoleStars, transformModule } from '../helpers';\nimport { CodebaseAnalysis, FileAnalysis } from '../schemas';\n\nconst transformModules = (\n  entries: [string, FileAnalysis][],\n  ...files: string[]\n) => {\n  const cwd = process.cwd();\n  const out = entries\n    .map(\n      ([key, { imports, relativePath }]) =>\n        [key, relativePath, imports] as const,\n    )\n    .map(([key, relativePath, imports]) => {\n      const specifiers = imports\n        .map(({ moduleSpecifier }) => {\n          return transformModule({\n            cwd,\n            relativePath,\n            moduleSpecifier,\n          });\n        })\n        .map(_path => [_path, `${_path}.index`]) // Ajouter les variantes .index\n        .flat()\n        .filter(s => files.includes(s));\n\n      return [key, Array.from(new Set(specifiers))] as const;\n    });\n\n  return out;\n};\n\n/**\n * remove variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const remove = (\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n  ...paths: string[]\n) => {\n  const isEmpty = paths.length === 0;\n  if (isEmpty) return console.warn('No files specified for removal.');\n  try {\n    const cwd = process.cwd();\n    const json = join(cwd, JSON_FILE_NAME);\n    let file: JsonEditor | undefined = edit(json);\n\n    if (!file) return;\n\n    const bemedevPath = file.get(PATH_PROPERTY) as string;\n    const files = file.get(FILES_PROPERTY) as string[];\n\n    // Vérifier les dépendances avant suppression\n    const safesToRemove: string[] = [];\n    const cannotRemoves2: [string, string[]][] = [];\n\n    const entries2 = Object.entries(CODEBASE_ANALYSIS).filter(([key]) =>\n      files.includes(key),\n    );\n\n    const entries = entries2.filter(([key]) =>\n      paths.some(p => key.startsWith(p)),\n    );\n\n    entries.forEach(([key]) => {\n      const modules = transformModules(entries2, ...files);\n      const importedFroms = modules\n        .filter(([, specifiers]) => specifiers.includes(key))\n        .map(([k]) => k);\n\n      const check = importedFroms.length > 0;\n\n      console.log('modules', '=>', importedFroms);\n      console.log('key', '=>', key);\n\n      if (check) return cannotRemoves2.push([key, importedFroms]);\n      return safesToRemove.push(key);\n    });\n\n    consoleStars();\n    console.log(\n      `🔧 Suppression des fichiers (${entries.length} fichiers)...`,\n    );\n\n    // Afficher les fichiers qui ne peuvent pas être supprimés\n    if (cannotRemoves2.length > 0) {\n      const len = cannotRemoves2.length;\n      const one =\n        \"fichier ne peut pas être supprimé (importé dans d'autres fichiers)\";\n      const many =\n        \"fichiers ne peuvent pas être supprimés (importés dans d'autres fichiers)\";\n\n      console.warn(`⚠️  ${len} ${len === 1 ? one : many} :`);\n      cannotRemoves2.forEach(([key, modules]) => {\n        console.warn(`  - ⚠️  ${key} importé par :`);\n        modules.forEach(m => console.warn(`    -> 📌 ${m}`));\n      });\n    }\n\n    if (safesToRemove.length === 0) {\n      console.warn('❌ Aucun fichier ne peut être supprimé.');\n      return consoleStars();\n    }\n\n    const formatteds = safesToRemove.map(key => {\n      const _path = `${key.replaceAll('.', '/')}.ts`;\n      const absolute = join(cwd, bemedevPath, _path);\n      return [key, absolute] as const;\n    });\n\n    console.log(\n      `🗑️ Suppression des fichiers (${safesToRemove.length} fichiers)...`,\n    );\n\n    let success = 0;\n    const length = formatteds.length;\n\n    formatteds.forEach(([key, path]) => {\n      try {\n        unlinkSync(path);\n        console.log(`  - 🗑️ ${key}`);\n        file?.set(\n          FILES_PROPERTY,\n          files.filter(key1 => key1 !== key),\n        );\n        success++;\n      } catch (error) {\n        console.error(`  - ❌ Erreur, ${key} :`, error);\n      }\n    });\n\n    file.save();\n    console.log(`🗑️ Fichiers supprimés! (${success}/${length})`);\n    file = undefined;\n  } catch {\n    console.error(`❌ Erreur lors de la création des fichiers`);\n    consoleStars();\n    return false;\n  }\n  consoleStars();\n  return true;\n};\n\n    "
    }
  }
}