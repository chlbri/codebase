{
  "STATS": {
    "files": 24,
    "imports": 63,
    "exports": 56
  },
  "CODE_ANALYSIS": {
    "analyse": {
      "imports": [
        {
          "moduleSpecifier": "path",
          "kind": "named",
          "namedImports": [
            "join",
            "relative"
          ]
        },
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "Project"
          ]
        },
        {
          "moduleSpecifier": "./utils",
          "kind": "named",
          "namedImports": [
            "pathToDotNotation"
          ]
        },
        {
          "moduleSpecifier": "./analyse.utils",
          "kind": "named",
          "namedImports": [
            "addJSDocToSourceText"
          ]
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "SRC_DIR"
          ]
        },
        {
          "moduleSpecifier": "./exports",
          "kind": "named",
          "namedImports": [
            "analyzeExports"
          ]
        },
        {
          "moduleSpecifier": "./imports",
          "kind": "named",
          "namedImports": [
            "analyzeImports",
            "buildImportStrings"
          ]
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis"
          ]
        }
      ],
      "relativePath": "analyse.ts",
      "text": "import { join, relative } from 'path';\nimport { Project } from 'ts-morph';\nimport { pathToDotNotation } from './utils';\nimport { addJSDocToSourceText } from './analyse.utils';\nimport { SRC_DIR } from './constants';\nimport { analyzeExports } from './exports';\nimport { analyzeImports, buildImportStrings } from './imports';\nimport { CodebaseAnalysis } from './types';\n\n/**\n * Analyse tous les fichiers TypeScript dans src/ (sauf src/scripts/)\n */\n/**\n * analyze variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const analyze = (): CodebaseAnalysis => {\n  console.log('üîç Analyse du codebase en cours...');\n\n  // Initialiser le projet ts-morph\n  const project = new Project({\n    tsConfigFilePath: join(process.cwd(), 'tsconfig.json'),\n  });\n\n  // Ajouter tous les fichiers TypeScript du dossier src\n  const sourceFiles = project.addSourceFilesAtPaths([\n    'src/**/*.ts',\n    '!src/scripts/**/*', // Exclure le dossier scripts\n    '!src/features/typescript/**/*', // Exclure le dossier typescript\n    '!src/**/*.test.ts', // Exclure les fichiers de test\n    '!src/**/*.spec.ts', // Exclure les fichiers de spec\n  ]);\n\n  const analysis: CodebaseAnalysis = {};\n  let processedCount = 0;\n\n  for (const sourceFile of sourceFiles) {\n    const filePath = sourceFile.getFilePath();\n    const relativePath = relative(SRC_DIR, filePath);\n\n    // G√©n√©rer le texte modifi√© avec JSDoc pour les exports\n\n    const _text = addJSDocToSourceText(sourceFile);\n\n    // #region Analyser les imports et exports\n    const imports = analyzeImports(sourceFile);\n    const exports = analyzeExports(sourceFile);\n    // #endregion\n\n    // Construire les imports √† partir de fileAnalysis.imports\n    const importsStrings = buildImportStrings(imports);\n\n    // Combiner imports et contenu\n    const importsSection =\n      importsStrings.length > 0 ? importsStrings.join('\\n') : '';\n\n    const text =\n      importsSection === ''\n        ? _text\n        : `${importsSection}\n\n${_text}\n    `;\n\n    analysis[pathToDotNotation(relativePath)] = {\n      relativePath,\n      imports,\n      exports,\n      text,\n    };\n\n    processedCount++;\n\n    // #region Afficher l'avancement de l'analyse par palliers de 50\n    if (processedCount % 50 === 0) {\n      console.log(\n        `üìä Analys√© ${processedCount}/${sourceFiles.length} fichiers...`,\n      );\n    }\n    // #endregion\n  }\n\n  console.log(`‚úÖ Analyse termin√©e: ${processedCount} fichiers analys√©s`);\n  return analysis;\n};\n\n    "
    },
    "analyse.utils": {
      "imports": [
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "SourceFile"
          ]
        }
      ],
      "relativePath": "analyse.utils.ts",
      "text": "import { SourceFile } from 'ts-morph';\n\n/**\n * G√©n√®re un JSDoc pour une expression export√©e g√©n√©r√©e automatiquement\n */\n/**\n * generateJSDoc variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const generateJSDoc = (\n  exportName: string,\n  declarationKind?: string,\n): string => {\n  const kindText = declarationKind ? ` ${declarationKind}` : '';\n  return `/**\n * ${exportName}${kindText} - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */`;\n};\n\n/**\n * extractExportDetails variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const extractExportDetails = (trimmedLine: string) => {\n  let exportName = 'export';\n  let declarationKind: string | undefined;\n\n  if (trimmedLine.includes('export default ')) {\n    exportName = 'default';\n    if (trimmedLine.includes('function')) declarationKind = 'function';\n    else if (trimmedLine.includes('class')) declarationKind = 'class';\n    else declarationKind = 'value';\n  } else if (trimmedLine.includes('export const ')) {\n    const match = trimmedLine.match(/export const (\\w+)/);\n    exportName = match ? match[1] : 'const';\n    declarationKind = 'variable';\n  } else if (trimmedLine.includes('export let ')) {\n    const match = trimmedLine.match(/export let (\\w+)/);\n    exportName = match ? match[1] : 'let';\n    declarationKind = 'variable';\n  } else if (trimmedLine.includes('export var ')) {\n    const match = trimmedLine.match(/export var (\\w+)/);\n    exportName = match ? match[1] : 'var';\n    declarationKind = 'variable';\n  } else if (trimmedLine.includes('export function ')) {\n    const match = trimmedLine.match(/export function (\\w+)/);\n    exportName = match ? match[1] : 'function';\n    declarationKind = 'function';\n  } else if (trimmedLine.includes('export class ')) {\n    const match = trimmedLine.match(/export class (\\w+)/);\n    exportName = match ? match[1] : 'class';\n    declarationKind = 'class';\n  } else if (trimmedLine.includes('export interface ')) {\n    const match = trimmedLine.match(/export interface (\\w+)/);\n    exportName = match ? match[1] : 'interface';\n    declarationKind = 'interface';\n  } else if (trimmedLine.includes('export type ')) {\n    const match = trimmedLine.match(/export type (\\w+)/);\n    exportName = match ? match[1] : 'type';\n    declarationKind = 'type';\n  } else if (trimmedLine.includes('export enum ')) {\n    const match = trimmedLine.match(/export enum (\\w+)/);\n    exportName = match ? match[1] : 'enum';\n    declarationKind = 'enum';\n  }\n  return { exportName, declarationKind };\n};\n\n/**\n * V√©rifie si une ligne d'export contient une d√©claration et non pas un simple re-export\n */\n/**\n * hasDeclaration variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const hasDeclaration = (exportLine: string): boolean => {\n  const trimmed = exportLine.trim();\n  const falsy =\n    trimmed.startsWith('export {') || // export { something }\n    trimmed.startsWith('export *') || // export * from\n    trimmed.includes('} from ') || // export { a, b } from\n    trimmed.match(/^export\\s+\\{[^}]*\\}\\s*;?\\s*$/) || // export { a, b };\n    trimmed.match(/^export\\s+default\\s+[a-zA-Z_$][a-zA-Z0-9_$]*\\s*;?\\s*$/); // export default identifier;\n\n  // Re-exports et exports simples √† exclure\n  if (falsy) return false;\n\n  // D√©clarations √† inclure (avec mots-cl√©s de d√©claration)\n  const keywords = [\n    'export const ',\n    'export let ',\n    'export var ',\n    'export function ',\n    'export class ',\n    'export interface ',\n    'export type ',\n    'export enum ',\n    'export namespace ',\n    'export default function ',\n    'export default class ',\n    'export default interface ',\n    'export default enum ',\n    'export default const ',\n    'export default let ',\n    'export default var ',\n  ];\n\n  return keywords.some(kw => trimmed.includes(kw));\n};\n\n/**\n * Extrait le nom d'une d√©claration (const, function, etc.)\n */\n/**\n * extractDeclarationName variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const extractDeclarationName = (line: string): string | null => {\n  const trimmed = line.trim();\n\n  if (trimmed.startsWith('const ')) {\n    const match = trimmed.match(/const\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('function ')) {\n    const match = trimmed.match(/function\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('class ')) {\n    const match = trimmed.match(/class\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('interface ')) {\n    const match = trimmed.match(/interface\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('type ')) {\n    const match = trimmed.match(/type\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n  if (trimmed.startsWith('enum ')) {\n    const match = trimmed.match(/enum\\s+(\\w+)/);\n    return match ? match[1] : null;\n  }\n\n  return null;\n};\n\n/**\n * V√©rifie si une d√©claration est export√©e plus tard dans le fichier\n */\n/**\n * isExportedLater variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const isExportedLater = (\n  lines: string[],\n  declarationName: string,\n): boolean => {\n  return lines.some(line => {\n    const trimmed = line.trim();\n    return (\n      trimmed === `export default ${declarationName};` ||\n      trimmed.includes(`export { ${declarationName}`) ||\n      trimmed.includes(`export * as ${declarationName}`)\n    );\n  });\n};\n\n/**\n * D√©termine le type de d√©claration\n */\n/**\n * getDeclarationKind variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const getDeclarationKind = (line: string): string => {\n  const trimmed = line.trim();\n\n  if (trimmed.startsWith('const ')) return 'const';\n  if (trimmed.startsWith('let ')) return 'let';\n  if (trimmed.startsWith('var ')) return 'var';\n  if (trimmed.startsWith('function ')) return 'function';\n  if (trimmed.startsWith('class ')) return 'class';\n  if (trimmed.startsWith('interface ')) return 'interface';\n  if (trimmed.startsWith('type ')) return 'type';\n  if (trimmed.startsWith('enum ')) return 'enum';\n\n  return 'variable';\n};\n\n/**\n * Ajoute des JSDoc aux expressions export√©es dans le texte source\n */\n/**\n * addJSDocToSourceText variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const addJSDocToSourceText = (sourceFile: SourceFile): string => {\n  // Obtenir le texte sans les imports d√®s le d√©but\n  const fullText = sourceFile.getText();\n  const imports = sourceFile\n    .getImportDeclarations()\n    .map(importDecl => importDecl.getText());\n\n  const linesWithoutImports = fullText\n    .replace(imports.join('\\n'), '')\n    .trimStart();\n\n  let modifiedText = linesWithoutImports;\n\n  // Collecter toutes les positions d'insertion avec leurs JSDoc\n  const insertions: Array<{ position: number; jsdoc: string }> = [];\n\n  // Une approche plus simple : analyser le texte directement pour trouver les exports\n  const lines = modifiedText.split('\\n');\n\n  lines.forEach((line, lineIndex) => {\n    const trimmedLine = line.trim();\n\n    // D√©tecter les lignes qui commencent par export ET contiennent une d√©claration\n    if (trimmedLine.startsWith('export ') && hasDeclaration(trimmedLine)) {\n      // Calculer la position dans le texte original\n      const position =\n        lines.slice(0, lineIndex).join('\\n').length +\n        (lineIndex > 0 ? 1 : 0);\n\n      // D√©terminer le nom et le type d'export\n      const { exportName, declarationKind } =\n        extractExportDetails(trimmedLine);\n\n      const jsdoc = generateJSDoc(exportName, declarationKind);\n      insertions.push({ position, jsdoc: `${jsdoc}\\n` });\n    }\n\n    // D√©tecter les d√©clarations internes (const, function, etc.) qui sont ensuite export√©es\n    if (\n      !trimmedLine.startsWith('export ') &&\n      (trimmedLine.startsWith('const ') ||\n        trimmedLine.startsWith('function ') ||\n        trimmedLine.startsWith('class ') ||\n        trimmedLine.startsWith('interface ') ||\n        trimmedLine.startsWith('type ') ||\n        trimmedLine.startsWith('enum '))\n    ) {\n      // V√©rifier si cette d√©claration est export√©e plus tard dans le fichier\n      const declarationName = extractDeclarationName(trimmedLine);\n      if (declarationName && isExportedLater(lines, declarationName)) {\n        // Calculer la position dans le texte original\n        const position =\n          lines.slice(0, lineIndex).join('\\n').length +\n          (lineIndex > 0 ? 1 : 0);\n\n        const declarationKind = getDeclarationKind(trimmedLine);\n        const jsdoc = generateJSDoc(declarationName, declarationKind);\n        insertions.push({ position, jsdoc: `${jsdoc}\\n` });\n      }\n    }\n  });\n\n  // Trier par position d√©croissante pour ins√©rer de la fin vers le d√©but\n  insertions.sort((a, b) => b.position - a.position);\n\n  // Ins√©rer les JSDoc\n  for (const insertion of insertions) {\n    modifiedText =\n      modifiedText.slice(0, insertion.position) +\n      insertion.jsdoc +\n      modifiedText.slice(insertion.position);\n  }\n\n  return modifiedText;\n};\n\n    "
    },
    "cli": {
      "imports": [
        {
          "moduleSpecifier": "./write",
          "kind": "named",
          "namedImports": [
            "write"
          ]
        }
      ],
      "relativePath": "cli.ts",
      "text": "import { write } from './write';\n\n// Ex√©cuter si ce fichier est appel√© directement\nif (process.argv[1] && process.argv[1].endsWith('cli.ts')) {\n  write();\n}\n\n    "
    },
    "constants": {
      "imports": [
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "join"
          ]
        }
      ],
      "relativePath": "constants.ts",
      "text": "import { join } from 'node:path';\n\n/**\n * SRC_DIR variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const SRC_DIR = join(process.cwd(), 'src');\n/**\n * OUTPUT_FILE variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const OUTPUT_FILE = join(SRC_DIR, '.codebase.json');\n\nconst _REPLACER = '-|||-';\n\n/**\n * REPLACERS variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const REPLACERS = {\n  code: [\n    ['\\\\`', `${_REPLACER}w`],\n    ['`', '\\\\`'],\n    ['${', `$${_REPLACER}{`],\n    ['\\\\s', `${_REPLACER}s`],\n    ['\\\\w', `${_REPLACER}w`],\n  ],\n  init: [\n    [new RegExp('\\\\`', 'g'), '`'],\n    [_REPLACER, ''],\n  ],\n} as const;\n\n    "
    },
    "exports": {
      "imports": [
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "SourceFile",
            "SyntaxKind"
          ]
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": [
            "ExportInfo"
          ]
        }
      ],
      "relativePath": "exports.ts",
      "text": "import { SourceFile, SyntaxKind } from 'ts-morph';\nimport { ExportInfo } from './types';\n\n/**\n * analyzeExports variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const analyzeExports = (sourceFile: SourceFile) => {\n  const exports: ExportInfo[] = [];\n\n  // Export declarations (export ...)\n  sourceFile.getExportDeclarations().forEach(exportDecl => {\n    const moduleSpecifier = exportDecl.getModuleSpecifierValue();\n    const exportText = exportDecl.getText();\n\n    // Named exports\n    const namedExports = exportDecl.getNamedExports();\n    namedExports.forEach(namedExport => {\n      exports.push({\n        name: namedExport.getName(),\n        kind: 'named',\n        text: exportText,\n        moduleSpecifier,\n      });\n    });\n\n    // Namespace export (export * from '...')\n    if (exportDecl.isNamespaceExport()) {\n      exports.push({\n        name: '*',\n        kind: 'namespace',\n        text: exportText,\n        moduleSpecifier,\n      });\n    }\n  });\n\n  // Export assignments (export = ...)\n  sourceFile.getExportAssignments().forEach(exportAssignment => {\n    if (exportAssignment.isExportEquals()) {\n      exports.push({\n        name: 'default',\n        kind: 'default',\n        text: exportAssignment.getText(),\n      });\n    }\n  });\n\n  // Exported declarations (export function, export class, etc.)\n  sourceFile.getExportedDeclarations().forEach((declarations, name) => {\n    declarations.forEach(decl => {\n      let declarationKind: ExportInfo['declarationKind'];\n\n      if (decl.getKind() === SyntaxKind.FunctionDeclaration) {\n        declarationKind = 'function';\n      } else if (decl.getKind() === SyntaxKind.ClassDeclaration) {\n        declarationKind = 'class';\n      } else if (decl.getKind() === SyntaxKind.InterfaceDeclaration) {\n        declarationKind = 'interface';\n      } else if (decl.getKind() === SyntaxKind.TypeAliasDeclaration) {\n        declarationKind = 'type';\n      } else if (decl.getKind() === SyntaxKind.VariableDeclaration) {\n        declarationKind = 'variable';\n      } else if (decl.getKind() === SyntaxKind.EnumDeclaration) {\n        declarationKind = 'enum';\n      }\n\n      exports.push({\n        name,\n        kind: name === 'default' ? 'default' : 'named',\n        text: decl.getText(),\n        declarationKind,\n      });\n    });\n  });\n\n  return exports;\n};\n\n    "
    },
    "generate": {
      "imports": [
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis"
          ]
        }
      ],
      "relativePath": "generate.ts",
      "text": "import { CodebaseAnalysis } from './types';\n\n/**\n * G√©n√®re le code TypeScript pour l'analyse du codebase\n */\n/**\n * generate variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const generate = (analysis: CodebaseAnalysis): string => {\n  let code = `// Analyse automatique de la codebase\\n\\n`;\n\n  code += `export interface ImportInfo {\n  moduleSpecifier: string;\n  kind: 'default' | 'named' | 'namespace' | 'side-effect';\n  namedImports?: string[];\n  default?: string;\n  isDynamic?: boolean;\n}\n\n/**\n * ExportInfo interface - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport interface ExportInfo {\n  name: string;\n  kind: 'default' | 'named' | 'namespace';\n  text?: string;\n  moduleSpecifier?: string;\n  declarationKind?: 'function' | 'class' | 'interface' | 'type' | 'variable' | 'const' | 'let' | 'enum';\n}\n\n/**\n * FileAnalysis interface - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport interface FileAnalysis {\n  relativePath: string;\n  imports: ImportInfo[];\n  text: string;\n}\n\n/**\n * CodebaseAnalysis interface - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport interface CodebaseAnalysis {\n  [dotNotationKey: string]: FileAnalysis;\n}\n\n`;\n\n  code += `export const CODEBASE_ANALYSIS: CodebaseAnalysis = {\\n`;\n\n  // Trier les cl√©s par ordre alphab√©tique\n  const sortedKeys = Object.keys(analysis).sort();\n\n  sortedKeys.forEach((key, index) => {\n    const fileAnalysis = analysis[key];\n    // Convertir le chemin en notation dot comme dans .manifest.ts\n    const dotNotationKey = key;\n    const formattedKey = `'${dotNotationKey}'`;\n\n    code += `  ${formattedKey}: {\\n`;\n    code += `    relativePath: '${fileAnalysis.relativePath}',\\n`;\n\n    // Imports\n    code += `    imports: [\\n`;\n    fileAnalysis.imports.forEach(imp => {\n      code += `      {\\n`;\n      code += `        moduleSpecifier: '${imp.moduleSpecifier}',\\n`;\n      code += `        kind: '${imp.kind}',\\n`;\n      if (imp.namedImports) {\n        code += `        namedImports: [${imp.namedImports.map(ni => `'${ni}'`).join(', ')}],\\n`;\n      }\n      if (imp.default) {\n        code += `        default: '${imp.default}',\\n`;\n      }\n      if (imp.isDynamic) {\n        code += `        isDynamic: true,\\n`;\n      }\n      code += `      },\\n`;\n    });\n    code += `    ],\\n`;\n\n    // √âchapper les backticks pour qu'ils n'interrompent pas la template literal g√©n√©r√©e\n    //\n    const escapedTextForBackticks = fileAnalysis.text;\n\n    code += `    text: \\`${escapedTextForBackticks}\\`,\\n`;\n\n    code += `  },\\n`;\n\n    // Ajouter une ligne vide tous les 10 fichiers pour la lisibilit√©\n    if ((index + 1) % 10 === 0 && index < sortedKeys.length - 1) {\n      code += '\\n';\n    }\n  });\n\n  code += `};\\n\\n`;\n\n  // Ajouter des statistiques\n  code += `// Statistiques de l'analyse\\n`;\n  code += `export const ANALYSIS_STATS = {\\n`;\n  code += `  totalFiles: ${Object.keys(analysis).length},\\n`;\n  code += `  totalImports: ${Object.values(analysis).reduce((acc, file) => acc + file.imports.length, 0)},\\n`;\n  code += `  totalExports: ${Object.values(analysis).reduce((acc, file) => acc + file.exports.length, 0)},\\n`;\n  code += `};\\n`;\n\n  return code;\n};\n\n    "
    },
    "imports": {
      "imports": [
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "join",
            "relative"
          ]
        },
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "SourceFile",
            "SyntaxKind"
          ]
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": [
            "ImportInfo"
          ]
        }
      ],
      "relativePath": "imports.ts",
      "text": "import { join, relative } from 'node:path';\nimport { SourceFile, SyntaxKind } from 'ts-morph';\nimport { ImportInfo } from './types';\n\n/**\n * R√©sout le moduleSpecifier en utilisant les paths du tsconfig si il commence par \"#\"\n */\nconst resolveModuleSpecifier = (\n  sourceFile: SourceFile,\n  moduleSpecifier: string,\n): string => {\n  const paths = sourceFile.getProject().getCompilerOptions().paths;\n\n  if (!paths) return moduleSpecifier;\n\n  const baseUrl = sourceFile.getProject().getCompilerOptions().baseUrl;\n  const paths2 = Object.entries(paths);\n\n  // Chercher la correspondance dans les paths\n  for (const [pattern, mappings] of paths2) {\n    // Remplacer * par une regex pour matcher\n    const regexPattern = pattern.replace(/\\*/g, '(.*)');\n    const regex = new RegExp(`^${regexPattern}$`);\n    const match = moduleSpecifier.match(regex);\n\n    if (match) {\n      // Prendre le premier mapping disponible\n      const first = mappings[0];\n\n      // R√©soudre le chemin absolu\n      let relativedPath = baseUrl ? join(baseUrl, first) : first;\n\n      if (match[1]) {\n        relativedPath = relativedPath.replace('*', match[1]);\n      }\n\n      // Calculer le chemin relatif depuis le fichier source actuel\n      const sourceFileDir = relative(\n        process.cwd(),\n        sourceFile.getDirectoryPath(),\n      );\n      const relativePath = relative(sourceFileDir, relativedPath);\n\n      // S'assurer que le chemin relatif commence par ./ ou ../\n      return relativePath.startsWith('.')\n        ? relativePath\n        : `./${relativePath}`;\n    }\n  }\n\n  return moduleSpecifier;\n};\n\n/**\n * Analyse les imports d'un fichier\n */\n/**\n * analyzeImports variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const analyzeImports = (sourceFile: SourceFile): ImportInfo[] => {\n  const imports: ImportInfo[] = [];\n\n  // Import declarations (import ... from '...')\n  sourceFile.getImportDeclarations().forEach(importDecl => {\n    const rawModuleSpecifier = importDecl.getModuleSpecifierValue();\n    const moduleSpecifier = resolveModuleSpecifier(\n      sourceFile,\n      rawModuleSpecifier,\n    );\n\n    // Import default\n    const defaultImport = importDecl.getDefaultImport();\n    if (defaultImport) {\n      imports.push({\n        moduleSpecifier,\n        kind: 'default',\n        default: defaultImport.getText(),\n      });\n    }\n\n    // Import namespace (* as name)\n    const namespaceImport = importDecl.getNamespaceImport();\n    if (namespaceImport) {\n      imports.push({\n        moduleSpecifier,\n        kind: 'namespace',\n        default: namespaceImport.getText(),\n      });\n    }\n\n    // Named imports ({ name1, name2 })\n    const namedImports = importDecl.getNamedImports();\n    if (namedImports.length > 0) {\n      imports.push({\n        moduleSpecifier,\n        kind: 'named',\n        namedImports: namedImports.map(ni => ni.getName()),\n      });\n    }\n\n    // Side-effect import (import '...')\n    if (!defaultImport && !namespaceImport && namedImports.length === 0) {\n      imports.push({\n        moduleSpecifier,\n        kind: 'side-effect',\n      });\n    }\n  });\n\n  // Dynamic imports (import('...'))\n  sourceFile\n    .getDescendantsOfKind(SyntaxKind.CallExpression)\n    .forEach(callExpr => {\n      if (\n        callExpr.getExpression().getKind() === SyntaxKind.ImportKeyword\n      ) {\n        const arg = callExpr.getArguments()[0];\n        if (arg && arg.getKind() === SyntaxKind.StringLiteral) {\n          const rawModuleSpecifier = arg.getText().replace(/['\"]/g, '');\n          const moduleSpecifier = resolveModuleSpecifier(\n            sourceFile,\n            rawModuleSpecifier,\n          );\n          imports.push({\n            moduleSpecifier,\n            kind: 'side-effect',\n            isDynamic: true,\n          });\n        }\n      }\n    });\n\n  return imports;\n};\n\n/**\n * buildImportStrings variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const buildImportStrings = (imports: ImportInfo[]) => {\n  return imports.map(imp => {\n    switch (imp.kind) {\n      case 'named': {\n        const namedImports = imp.namedImports?.join(', ') || '';\n        return `import { ${namedImports} } from '${imp.moduleSpecifier}';`;\n      }\n      case 'namespace':\n        return `import * as ${imp.default} from '${imp.moduleSpecifier}';`;\n      case 'side-effect': {\n        if (imp.isDynamic) {\n          return `// Dynamic import: import('${imp.moduleSpecifier}')`;\n        }\n        return `import '${imp.moduleSpecifier}';`;\n      }\n\n      case 'default':\n        return `import ${imp.default} from '${imp.moduleSpecifier}';`;\n      default:\n        return '';\n    }\n  });\n};\n\n    "
    },
    "index": {
      "imports": [],
      "relativePath": "index.ts",
      "text": ""
    },
    "schemas": {
      "imports": [
        {
          "moduleSpecifier": "valibot",
          "kind": "namespace",
          "default": "v"
        }
      ],
      "relativePath": "schemas.ts",
      "text": "import * as v from 'valibot';\n\n// Schema pour DeclarationKind\n/**\n * DeclarationKindSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const DeclarationKindSchema = v.picklist([\n  'function',\n  'class',\n  'interface',\n  'type',\n  'variable',\n  'const',\n  'let',\n  'enum',\n]);\n\n// Schema pour ImportInfo\n/**\n * ImportInfoSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const ImportInfoSchema = v.object({\n  moduleSpecifier: v.string(),\n  kind: v.picklist(['default', 'named', 'namespace', 'side-effect']),\n  namedImports: v.optional(v.array(v.string())),\n  default: v.optional(v.string()),\n  isDynamic: v.optional(v.boolean()),\n});\n\n// Schema pour ExportInfo\n/**\n * ExportInfoSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const ExportInfoSchema = v.object({\n  name: v.string(),\n  kind: v.picklist(['default', 'named', 'namespace']),\n  text: v.optional(v.string()),\n  moduleSpecifier: v.optional(v.string()),\n  declarationKind: v.optional(DeclarationKindSchema),\n});\n\n// Schema pour FileAnalysis\n/**\n * FileAnalysisSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const FileAnalysisSchema = v.object({\n  relativePath: v.string(),\n  imports: v.array(ImportInfoSchema),\n  exports: v.array(ExportInfoSchema),\n  text: v.string(),\n});\n\n// Schema pour CodebaseAnalysis\n/**\n * CodebaseAnalysisSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const CodebaseAnalysisSchema = v.record(\n  v.string(),\n  FileAnalysisSchema,\n);\n\n// Schema pour les statistiques d'analyse\n/**\n * AnalysisStatsSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const AnalysisStatsSchema = v.object({\n  files: v.number(),\n  imports: v.number(),\n  exports: v.number(),\n});\n\n// Schema complet pour un fichier .code contenant l'analyse compl√®te\n/**\n * CodeAnalysisFileSchema variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const CodeAnalysisFileSchema = v.object({\n  CODEBASE_ANALYSIS: CodebaseAnalysisSchema,\n  STATS: v.optional(AnalysisStatsSchema),\n});\n\n// Types inf√©r√©s des sch√©mas\n/**\n * DeclarationKind type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeclarationKind = v.InferOutput<typeof DeclarationKindSchema>;\n/**\n * ImportInfo type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ImportInfo = v.InferOutput<typeof ImportInfoSchema>;\n/**\n * ExportInfo type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ExportInfo = v.InferOutput<typeof ExportInfoSchema>;\n/**\n * FileAnalysis type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type FileAnalysis = v.InferOutput<typeof FileAnalysisSchema>;\n/**\n * CodebaseAnalysis type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type CodebaseAnalysis = v.InferOutput<\n  typeof CodebaseAnalysisSchema\n>;\n/**\n * AnalysisStats type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type AnalysisStats = v.InferOutput<typeof AnalysisStatsSchema>;\n/**\n * CodeAnalysisFile type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type CodeAnalysisFile = v.InferOutput<\n  typeof CodeAnalysisFileSchema\n>;\n\n    "
    },
    "types": {
      "imports": [],
      "relativePath": "types.ts",
      "text": "/**\n * DeclarationKind type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeclarationKind =\n  | 'function'\n  | 'class'\n  | 'interface'\n  | 'type'\n  | 'variable'\n  | 'const'\n  | 'let'\n  | 'enum';\n\n/**\n * ImportInfo type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ImportInfo = {\n  /** Module import√© (ex: './utils', 'fs', etc.) */\n  moduleSpecifier: string;\n  /** Type d'import (default, named, namespace, etc.) */\n  kind: 'default' | 'named' | 'namespace' | 'side-effect';\n  /** Noms import√©s pour les imports named */\n  namedImports?: string[];\n  /** Nom de l'import default ou namespace */\n  default?: string;\n  /** Import dynamique */\n  isDynamic?: boolean;\n};\n\n/**\n * ExportInfo type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ExportInfo = {\n  /** Nom de l'export */\n  name: string;\n  /** Type d'export */\n  kind: 'default' | 'named' | 'namespace';\n  /** Texte complet de l'export */\n  text?: string;\n  /** Si c'est un re-export, le module source */\n  moduleSpecifier?: string;\n  /** Si c'est une d√©claration (function, class, etc.) */\n  declarationKind?: DeclarationKind;\n};\n\n/**\n * FileAnalysis type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type FileAnalysis = {\n  /** Chemin relatif du fichier depuis src/ */\n  relativePath: string;\n  /** Liste des imports du fichier */\n  imports: ImportInfo[];\n  /** Liste des exports du fichier */\n  exports: ExportInfo[];\n  text: string;\n};\n\n/**\n * CodebaseAnalysis type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type CodebaseAnalysis = Record<string, FileAnalysis>;\n"
    },
    "utils": {
      "imports": [],
      "relativePath": "utils.ts",
      "text": "/**\n * pathToDotNotation function - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport function pathToDotNotation(filePath: string): string {\n  return filePath\n    .replace(/\\.ts$/, '') // Enlever l'extension .ts\n    .replace(/\\//g, '.'); // Remplacer les / par des .\n}\n"
    },
    "write": {
      "imports": [
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "relative"
          ]
        },
        {
          "moduleSpecifier": "./analyse",
          "kind": "named",
          "namedImports": [
            "analyze"
          ]
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "OUTPUT_FILE"
          ]
        },
        {
          "moduleSpecifier": "node:fs",
          "kind": "named",
          "namedImports": [
            "writeFileSync"
          ]
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis"
          ]
        }
      ],
      "relativePath": "write.ts",
      "text": "import { relative } from 'node:path';\nimport { analyze } from './analyse';\nimport { OUTPUT_FILE } from './constants';\nimport { writeFileSync } from 'node:fs';\nimport { CodebaseAnalysis } from './types';\n\n/**\n * transformJSON variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const transformJSON = (data: CodebaseAnalysis) => {\n  let imports = 0;\n  let exports = 0;\n  let files = 0;\n\n  const entries = Object.entries(data).map(\n    ([\n      key,\n      { imports: _imports, relativePath, text, exports: _exports },\n    ]) => {\n      imports += _imports.length;\n      exports += _exports.length;\n      files++;\n      const value = {\n        imports: _imports,\n        relativePath,\n        text,\n      };\n      return [key, value] as const;\n    },\n  );\n\n  const CODE_ANALYSIS = Object.fromEntries(entries);\n\n  const STATS = {\n    files,\n    imports,\n    exports,\n  };\n\n  return {\n    STATS,\n    CODE_ANALYSIS,\n  };\n};\n\n/**\n * Fonction principale d'ex√©cution\n */\n/**\n * write variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const write = (output = OUTPUT_FILE) => {\n  const _output = output.endsWith('.json') ? output : `${output}.json`;\n\n  try {\n    const analysis = analyze();\n\n    const json = JSON.stringify(transformJSON(analysis), null, 2);\n    writeFileSync(_output, json);\n\n    const values = Object.values(analysis);\n    const keys = Object.keys(analysis);\n\n    console.log(\n      `üìÅ Analyse sauvegard√©e dans: ${relative(process.cwd(), _output)}`,\n    );\n    console.log(`üìä Statistiques:`);\n    console.log(`   - Fichiers analys√©s: ${keys.length}`);\n    console.log(\n      `   - Total imports: ${values.reduce((acc, file) => acc + file.imports.length, 0)}`,\n    );\n    console.log(\n      `   - Total exports: ${values.reduce((acc, file) => acc + file.exports.length, 0)}`,\n    );\n  } catch (error) {\n    console.error(\"‚ùå Erreur lors de l'analyse du codebase:\", error);\n    process.exit(1);\n  }\n};\n\n// Ex√©cuter si ce fichier est appel√© directement\nif (process.argv[1]) {\n  write();\n}\n\n    "
    },
    "installer.add": {
      "imports": [
        {
          "moduleSpecifier": "#codebase",
          "kind": "named",
          "namedImports": [
            "CODEBASE_ANALYSIS"
          ]
        },
        {
          "moduleSpecifier": "#features/common/castings/is/defined",
          "kind": "default",
          "default": "isD"
        },
        {
          "moduleSpecifier": "#types",
          "kind": "named",
          "namedImports": [
            "NOmit"
          ]
        },
        {
          "moduleSpecifier": "edit-json-file",
          "kind": "default",
          "default": "edit"
        },
        {
          "moduleSpecifier": "edit-json-file",
          "kind": "named",
          "namedImports": [
            "JsonEditor"
          ]
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "dirname",
            "join",
            "relative",
            "resolve"
          ]
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": [
            "FileAnalysis"
          ]
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "FILES_PROPERTY",
            "JSON_FILE_NAME",
            "PATH_PROPERTY"
          ]
        },
        {
          "moduleSpecifier": "./helpers",
          "kind": "named",
          "namedImports": [
            "consoleStars",
            "transformModule",
            "writeFileAnalysis"
          ]
        }
      ],
      "relativePath": "installer/add.ts",
      "text": "import { CODEBASE_ANALYSIS } from '#codebase';\nimport isD from '#features/common/castings/is/defined';\nimport { NOmit } from '#types';\nimport edit from 'edit-json-file';\nimport { JsonEditor } from 'edit-json-file';\nimport { dirname, join, relative, resolve } from 'node:path';\nimport { FileAnalysis } from '../types';\nimport { FILES_PROPERTY, JSON_FILE_NAME, PATH_PROPERTY } from './constants';\nimport { consoleStars, transformModule, writeFileAnalysis } from './helpers';\n\nconst processFileAnalysis = (\n  analysis: NOmit<FileAnalysis, 'exports'>,\n  cwd: string,\n  additionals: [string, NOmit<FileAnalysis, 'exports'>][],\n  pathsEntries: [string, NOmit<FileAnalysis, 'exports'>][],\n  files: string[],\n) => {\n  const relativePath = analysis.relativePath;\n  const keys = Object.keys(CODEBASE_ANALYSIS);\n  analysis.imports.forEach(({ moduleSpecifier }) => {\n    const _path = relative(\n      cwd,\n      resolve(dirname(relativePath), moduleSpecifier),\n    ).replaceAll('/', '.');\n\n    const toAdd =\n      CODEBASE_ANALYSIS[_path] ?? CODEBASE_ANALYSIS[`${_path}.index`];\n    if (!toAdd) return;\n\n    additionals.push([_path, toAdd]);\n\n    const all = additionals\n      .concat(pathsEntries)\n      .map(([key]) => key)\n      .concat(files);\n\n    const imports = toAdd.imports.filter(({ moduleSpecifier }) => {\n      const _path = transformModule({\n        cwd,\n        relativePath: toAdd.relativePath,\n        moduleSpecifier,\n      });\n\n      const array = [_path, `${_path}.index`].filter(p =>\n        keys.includes(p),\n      );\n\n      if (array.length < 1) return false;\n\n      return array.every(p => !all.includes(p));\n    });\n\n    const toAdd2 = { ...toAdd, imports };\n    const canRecurse = toAdd2.imports.length > 0;\n\n    if (canRecurse) {\n      processFileAnalysis(toAdd2, cwd, additionals, pathsEntries, files);\n    }\n  });\n};\n\n/**\n * addFiles variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const addFiles = (...paths: string[]) => {\n  try {\n    const cwd = process.cwd();\n    const json = join(cwd, JSON_FILE_NAME);\n    let file: JsonEditor | undefined = edit(json);\n\n    if (!file) return;\n\n    const path = file.get(PATH_PROPERTY) as string;\n    const files = file.get(FILES_PROPERTY) as string[];\n\n    // Release resources\n\n    const additionals: [string, NOmit<FileAnalysis, 'exports'>][] = [];\n\n    const pathsEntries = Object.entries(CODEBASE_ANALYSIS)\n      .filter(([key]) => paths.some(p => key.startsWith(p)))\n      .filter(([key]) => !files.includes(key));\n\n    pathsEntries.forEach(([, analysis]) => {\n      processFileAnalysis(analysis, cwd, additionals, pathsEntries, files);\n    });\n\n    const entries = new Set(\n      pathsEntries.concat(additionals).filter(([, val]) => isD(val)),\n    );\n\n    consoleStars();\n    console.log(`üîß Cr√©ation des fichiers (${entries.size} fichiers)...`);\n\n    let success = 0;\n    const length = entries.size;\n\n    entries.forEach(([, fileAnalysis]) => {\n      const _path = writeFileAnalysis(fileAnalysis, path);\n      if (_path) {\n        files.push(_path);\n        file?.set(FILES_PROPERTY, files);\n        success++;\n      }\n    });\n\n    file.save();\n    console.log(`‚úÖ Fichiers cr√©√©s! (${success}/${length})`);\n    file = undefined;\n  } catch {\n    console.error(`‚ùå Erreur lors de la cr√©ation des fichiers`);\n  }\n\n  consoleStars();\n};\n\n    "
    },
    "installer.constants": {
      "imports": [],
      "relativePath": "installer/constants.ts",
      "text": "/**\n * PATH_KEY variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const PATH_KEY = '#bemedev/*';\n/**\n * JSON_FILE_NAME variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const JSON_FILE_NAME = '.bemedev.json';\n\n/**\n * PATH_PROPERTY variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const PATH_PROPERTY = 'path';\n/**\n * FILES_PROPERTY variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const FILES_PROPERTY = 'files';\n"
    },
    "installer.helpers": {
      "imports": [
        {
          "moduleSpecifier": "node:fs",
          "kind": "named",
          "namedImports": [
            "mkdirSync",
            "writeFileSync"
          ]
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "dirname",
            "join",
            "relative",
            "resolve"
          ]
        },
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": [
            "REPLACERS"
          ]
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": [
            "FileAnalysis"
          ]
        }
      ],
      "relativePath": "installer/helpers.ts",
      "text": "import { mkdirSync, writeFileSync } from 'node:fs';\nimport { dirname, join, relative, resolve } from 'node:path';\nimport { REPLACERS } from '../constants';\nimport { FileAnalysis } from '../types';\n\n/**\n * TransformModuleArgs type - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type TransformModuleArgs = {\n  cwd?: string;\n  relativePath: string;\n  moduleSpecifier: string;\n};\n\n/**\n * transformModule variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const transformModule = ({\n  cwd = process.cwd(),\n  relativePath,\n  moduleSpecifier,\n}: TransformModuleArgs) => {\n  const out = relative(\n    cwd,\n    resolve(dirname(relativePath), moduleSpecifier),\n  ).replaceAll('/', '.');\n\n  return out;\n};\n\n/**\n * writeFileAnalysis variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const writeFileAnalysis = (\n  fileAnalysis: FileAnalysis,\n  bemedevPath: string,\n) => {\n  const relativePath = fileAnalysis.relativePath;\n\n  // Cr√©er le chemin de destination dans .bemedev en maintenant la structure\n  const destPath = join(bemedevPath, relativePath);\n  const destDir = dirname(destPath);\n\n  try {\n    // Cr√©er le dossier de destination si n√©cessaire\n    mkdirSync(destDir, { recursive: true });\n\n    let fileContent = fileAnalysis.text;\n    REPLACERS.init\n      // .filter(() => false)\n      .forEach(([search, replace]) => {\n        fileContent = fileContent.replaceAll(search, replace);\n      });\n\n    // √âcrire le contenu du fichier types\n    writeFileSync(destPath, fileContent, 'utf8');\n\n    console.log(`  ‚úÖ ${relativePath}`);\n    return relativePath.slice(0, -3).replaceAll('/', '.');\n  } catch (error) {\n    return console.error(`  ‚ùå Erreur pour ${relativePath}:`, error);\n  }\n};\n\n/**\n * consoleStars variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const consoleStars = () => {\n  console.log();\n  console.log('*'.repeat(30));\n  console.log();\n};\n\n    "
    },
    "installer.init": {
      "imports": [
        {
          "moduleSpecifier": "node:fs",
          "kind": "named",
          "namedImports": [
            "existsSync",
            "mkdirSync",
            "readFileSync",
            "writeFileSync"
          ]
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "join"
          ]
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "FILES_PROPERTY",
            "JSON_FILE_NAME",
            "PATH_KEY",
            "PATH_PROPERTY"
          ]
        },
        {
          "moduleSpecifier": "./helpers",
          "kind": "named",
          "namedImports": [
            "writeFileAnalysis"
          ]
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis"
          ]
        }
      ],
      "relativePath": "installer/init.ts",
      "text": "import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { FILES_PROPERTY, JSON_FILE_NAME, PATH_KEY, PATH_PROPERTY } from './constants';\nimport { writeFileAnalysis } from './helpers';\nimport { CodebaseAnalysis } from '../types';\n\n/**\n * InitOptions interface - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport interface InitOptions {\n  /**\n   * Emplacement personnalis√© pour le dossier .bemedev\n   * Par d√©faut: 'src/.bemedev' si src existe, sinon '.bemedev' √† la racine\n   */\n  path?: string;\n}\n\n/**\n * createTypesStructure variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const createTypesStructure = (\n  bemedevPath: string,\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n) => {\n  const entries = Object.entries(CODEBASE_ANALYSIS).filter(([key]) => {\n    return key.endsWith('.types') || key.endsWith('.constants');\n  });\n\n  const PATHS: string[] = [];\n\n  console.log(\n    `üîß Cr√©ation de la structure de types (${entries.length} fichiers)...`,\n  );\n\n  for (const [, fileAnalysis] of entries) {\n    const file = writeFileAnalysis(fileAnalysis, bemedevPath);\n    if (file) PATHS.push(file);\n  }\n\n  console.log(`‚úÖ Structure de types cr√©√©e avec succ√®s!`);\n  return PATHS;\n};\n\n/**\n * initBemedev variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const initBemedev = (\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n  options?: InitOptions,\n) => {\n  const cwd = process.cwd();\n  const configFile = join(cwd, JSON_FILE_NAME);\n  const configExists = existsSync(configFile);\n\n  if (configExists) return true;\n\n  const srcExists = existsSync(join(cwd, 'src'));\n\n  // D√©terminer l'emplacement du dossier .bemedev\n  const path = options?.path ?? (srcExists ? 'src/.bemedev' : '.bemedev');\n  const bemedevPath = join(cwd, path);\n\n  // 1. Cr√©er le dossier .bemedev\n  try {\n    mkdirSync(join(bemedevPath), { recursive: true });\n    console.log(`‚úÖ Dossier .bemedev cr√©√© dans: ${path}`);\n  } catch (error) {\n    console.error(\n      `‚ùå Erreur lors de la cr√©ation du dossier .bemedev:`,\n      error,\n    );\n    return false;\n  }\n\n  let files: string[] = [];\n  // 1.5. Cr√©er la structure des fichiers types\n  try {\n    files = createTypesStructure(bemedevPath, CODEBASE_ANALYSIS);\n  } catch (error) {\n    console.error(\n      `‚ùå Erreur lors de la cr√©ation de la structure de types:`,\n      error,\n    );\n    return false;\n  }\n\n  // 2. Mettre √† jour le tsconfig.json\n  const tsconfigPath = join(cwd, 'tsconfig.json');\n\n  if (existsSync(tsconfigPath)) {\n    try {\n      const tsconfigContent = readFileSync(tsconfigPath, 'utf8');\n      const tsconfig = JSON.parse(tsconfigContent);\n\n      // Initialiser compilerOptions et paths si ils n'existent pas\n      if (!tsconfig.compilerOptions) {\n        tsconfig.compilerOptions = {};\n      }\n      if (!tsconfig.compilerOptions.paths) {\n        tsconfig.compilerOptions.paths = {};\n      }\n\n      // Ajouter le path #bemedev/*\n      let relativePath = path;\n      const baseUrl = tsconfig.compilerOptions.baseUrl;\n\n      if (typeof baseUrl === 'string') {\n        // Si baseUrl est d√©fini, calculer le chemin relatif par rapport √† baseUrl\n\n        relativePath = join(baseUrl, relativePath);\n      }\n\n      tsconfig.compilerOptions.paths[PATH_KEY] = [`${relativePath}/*`];\n\n      writeFileSync(\n        tsconfigPath,\n        JSON.stringify(tsconfig, null, 2),\n        'utf8',\n      );\n      console.log(`‚úÖ Path #bemedev/* ajout√© au tsconfig.json`);\n    } catch (error) {\n      console.error(\n        `‚ùå Erreur lors de la mise √† jour du tsconfig.json:`,\n        error,\n      );\n      return false;\n    }\n  } else {\n    console.warn(`‚ö†Ô∏è Fichier tsconfig.json introuvable, path non ajout√©`);\n  }\n\n  // 3. Cr√©er le fichier .bemedev.json √† la racine\n\n  const config = {\n    version: '1.0.0',\n    [PATH_PROPERTY]: path,\n    [FILES_PROPERTY]: files,\n  };\n\n  try {\n    writeFileSync(configFile, JSON.stringify(config, null, 2), 'utf8');\n    console.log(`‚úÖ Fichier .bemedev.json cr√©√© √† la racine du projet`);\n  } catch (error) {\n    console.error(\n      `‚ùå Erreur lors de la cr√©ation du fichier .bemedev.json:`,\n      error,\n    );\n    return false;\n  }\n\n  console.log(`üéâ Initialisation de bemedev termin√©e avec succ√®s!`);\n  return true;\n};\n\n    "
    },
    "installer.remove": {
      "imports": [
        {
          "moduleSpecifier": "edit-json-file",
          "kind": "default",
          "default": "edit"
        },
        {
          "moduleSpecifier": "edit-json-file",
          "kind": "named",
          "namedImports": [
            "JsonEditor"
          ]
        },
        {
          "moduleSpecifier": "node:fs",
          "kind": "named",
          "namedImports": [
            "unlinkSync"
          ]
        },
        {
          "moduleSpecifier": "node:path",
          "kind": "named",
          "namedImports": [
            "join"
          ]
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "FILES_PROPERTY",
            "JSON_FILE_NAME",
            "PATH_PROPERTY"
          ]
        },
        {
          "moduleSpecifier": "./helpers",
          "kind": "named",
          "namedImports": [
            "consoleStars",
            "transformModule"
          ]
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": [
            "CodebaseAnalysis",
            "FileAnalysis"
          ]
        }
      ],
      "relativePath": "installer/remove.ts",
      "text": "import edit from 'edit-json-file';\nimport { JsonEditor } from 'edit-json-file';\nimport { unlinkSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { FILES_PROPERTY, JSON_FILE_NAME, PATH_PROPERTY } from './constants';\nimport { consoleStars, transformModule } from './helpers';\nimport { CodebaseAnalysis, FileAnalysis } from '../types';\n\nconst transformModules = (\n  entries: [string, FileAnalysis][],\n  ...files: string[]\n) => {\n  const cwd = process.cwd();\n  const out = entries\n    .map(\n      ([key, { imports, relativePath }]) =>\n        [key, relativePath, imports] as const,\n    )\n    .map(([key, relativePath, imports]) => {\n      const specifiers = imports\n        .map(({ moduleSpecifier }) => {\n          return transformModule({\n            cwd,\n            relativePath,\n            moduleSpecifier,\n          });\n        })\n        .map(_path => [_path, `${_path}.index`]) // Ajouter les variantes .index\n        .flat()\n        .filter(s => files.includes(s));\n\n      return [key, Array.from(new Set(specifiers))] as const;\n    });\n\n  return out;\n};\n\n/**\n * removeFiles variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const removeFiles = (\n  CODEBASE_ANALYSIS: CodebaseAnalysis,\n  ...paths: string[]\n) => {\n  try {\n    const cwd = process.cwd();\n    const json = join(cwd, JSON_FILE_NAME);\n    let file: JsonEditor | undefined = edit(json);\n\n    if (!file) return;\n\n    const bemedevPath = file.get(PATH_PROPERTY) as string;\n    const files = file.get(FILES_PROPERTY) as string[];\n\n    // V√©rifier les d√©pendances avant suppression\n    const safesToRemove: string[] = [];\n    const cannotRemoves2: [string, string[]][] = [];\n\n    const entries2 = Object.entries(CODEBASE_ANALYSIS).filter(([key]) =>\n      files.includes(key),\n    );\n\n    const entries = entries2.filter(([key]) =>\n      paths.some(p => key.startsWith(p)),\n    );\n\n    entries.forEach(([key]) => {\n      const modules = transformModules(entries2, ...files);\n      const importedFroms = modules\n        .filter(([, specifiers]) => specifiers.includes(key))\n        .map(([k]) => k);\n\n      const check = importedFroms.length > 0;\n\n      console.log('modules', '=>', importedFroms);\n      console.log('key', '=>', key);\n\n      if (check) return cannotRemoves2.push([key, importedFroms]);\n      return safesToRemove.push(key);\n    });\n\n    consoleStars();\n    console.log(\n      `üîß Suppression des fichiers (${entries.length} fichiers)...`,\n    );\n\n    // Afficher les fichiers qui ne peuvent pas √™tre supprim√©s\n    if (cannotRemoves2.length > 0) {\n      const len = cannotRemoves2.length;\n      const one =\n        \"fichier ne peut pas √™tre supprim√© (import√© dans d'autres fichiers)\";\n      const many =\n        \"fichiers ne peuvent pas √™tre supprim√©s (import√©s dans d'autres fichiers)\";\n\n      console.warn(`‚ö†Ô∏è  ${len} ${len === 1 ? one : many} :`);\n      cannotRemoves2.forEach(([key, modules]) => {\n        console.warn(`  - ‚ö†Ô∏è  ${key} import√© par :`);\n        modules.forEach(m => console.warn(`    -> üìå ${m}`));\n      });\n    }\n\n    if (safesToRemove.length === 0) {\n      console.warn('‚ùå Aucun fichier ne peut √™tre supprim√©.');\n      return consoleStars();\n    }\n\n    const formatteds = safesToRemove.map(key => {\n      const _path = `${key.replaceAll('.', '/')}.ts`;\n      const absolute = join(cwd, bemedevPath, _path);\n      return [key, absolute] as const;\n    });\n\n    console.log(\n      `üóëÔ∏è Suppression des fichiers (${safesToRemove.length} fichiers)...`,\n    );\n\n    let success = 0;\n    const length = formatteds.length;\n\n    formatteds.forEach(([key, path]) => {\n      try {\n        unlinkSync(path);\n        console.log(`  - üóëÔ∏è ${key}`);\n        file?.set(\n          FILES_PROPERTY,\n          files.filter(key1 => key1 !== key),\n        );\n        success++;\n      } catch (error) {\n        console.error(`  - ‚ùå Erreur, ${key} :`, error);\n      }\n    });\n\n    file.save();\n    console.log(`üóëÔ∏è Fichiers supprim√©s! (${success}/${length})`);\n    file = undefined;\n  } catch {\n    console.error(`‚ùå Erreur lors de la cr√©ation des fichiers`);\n  }\n\n  consoleStars();\n};\n\n    "
    },
    "installer.cli.add": {
      "imports": [
        {
          "moduleSpecifier": "cmd-ts",
          "kind": "named",
          "namedImports": [
            "command",
            "restPositionals",
            "string"
          ]
        },
        {
          "moduleSpecifier": "../add",
          "kind": "named",
          "namedImports": [
            "addFiles"
          ]
        }
      ],
      "relativePath": "installer/cli/add.ts",
      "text": "import { command, restPositionals, string } from 'cmd-ts';\nimport { addFiles } from '../add';\n\n/**\n * add variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const add = command({\n  name: 'addFiles',\n  aliases: ['add', 'add2'],\n\n  args: {\n    files: restPositionals({\n      description: 'The files to generate, relative to @bemedev/core/src',\n      displayName: 'Files',\n      type: string,\n    }),\n  },\n  handler: async ({ files }) => {\n    const isEmpty = files.length === 0;\n    if (isEmpty) return console.warn('No files specified for addition.');\n    return addFiles(...files);\n  },\n});\n\n    "
    },
    "installer.cli.cli": {
      "imports": [
        {
          "moduleSpecifier": "cmd-ts",
          "kind": "named",
          "namedImports": [
            "subcommands"
          ]
        },
        {
          "moduleSpecifier": "./add",
          "kind": "named",
          "namedImports": [
            "add"
          ]
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "BIN"
          ]
        },
        {
          "moduleSpecifier": "./init",
          "kind": "named",
          "namedImports": [
            "init"
          ]
        },
        {
          "moduleSpecifier": "./remove",
          "kind": "named",
          "namedImports": [
            "remove"
          ]
        }
      ],
      "relativePath": "installer/cli/cli.ts",
      "text": "import { subcommands } from 'cmd-ts';\nimport { add } from './add';\nimport { BIN } from './constants';\nimport { init } from './init';\nimport { remove } from './remove';\n\n/**\n * cli variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const cli = subcommands({\n  name: BIN,\n  description: 'The CLI for bemedev',\n  cmds: {\n    add,\n    init,\n    remove,\n  },\n  version: '0.0.1',\n});\n\n    "
    },
    "installer.cli.constants": {
      "imports": [],
      "relativePath": "installer/cli/constants.ts",
      "text": "/**\n * BIN variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const BIN = 'bemedev';\n"
    },
    "installer.cli.generate": {
      "imports": [
        {
          "moduleSpecifier": "cmd-ts",
          "kind": "named",
          "namedImports": [
            "command",
            "option",
            "string"
          ]
        },
        {
          "moduleSpecifier": "../init",
          "kind": "named",
          "namedImports": [
            "initBemedev"
          ]
        }
      ],
      "relativePath": "installer/cli/generate.ts",
      "text": "import { command, option, string } from 'cmd-ts';\nimport { initBemedev } from '../init';\n\n/**\n * init variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const init = command({\n  name: 'initialize',\n\n  args: {\n    path: option({\n      long: 'path',\n      description: 'The path of the main folder',\n      short: 'p',\n      // displayName: 'Path',\n      type: string,\n      defaultValue: () => 'src/.bemedev',\n    }),\n  },\n  handler,\n});\n\n    "
    },
    "installer.cli.index": {
      "imports": [
        {
          "moduleSpecifier": "cmd-ts",
          "kind": "named",
          "namedImports": [
            "run"
          ]
        },
        {
          "moduleSpecifier": "./cli",
          "kind": "named",
          "namedImports": [
            "cli"
          ]
        }
      ],
      "relativePath": "installer/cli/index.ts",
      "text": "import { run } from 'cmd-ts';\nimport { cli } from './cli';\n\nrun(cli, process.argv.slice(2));\n\n    "
    },
    "installer.cli.init": {
      "imports": [
        {
          "moduleSpecifier": "cmd-ts",
          "kind": "named",
          "namedImports": [
            "command",
            "option",
            "string"
          ]
        },
        {
          "moduleSpecifier": "../init",
          "kind": "named",
          "namedImports": [
            "initBemedev"
          ]
        }
      ],
      "relativePath": "installer/cli/init.ts",
      "text": "import { command, option, string } from 'cmd-ts';\nimport { initBemedev } from '../init';\n\n/**\n * init variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const init = command({\n  name: 'initialize',\n\n  args: {\n    path: option({\n      long: 'path',\n      description: 'The path of the main folder',\n      short: 'p',\n      // displayName: 'Path',\n      type: string,\n      defaultValue: () => 'src/.bemedev',\n    }),\n  },\n  handler: options,\n});\n\n    "
    },
    "installer.cli.remove": {
      "imports": [
        {
          "moduleSpecifier": "cmd-ts",
          "kind": "named",
          "namedImports": [
            "command",
            "restPositionals",
            "string"
          ]
        },
        {
          "moduleSpecifier": "../remove",
          "kind": "named",
          "namedImports": [
            "removeFiles"
          ]
        }
      ],
      "relativePath": "installer/cli/remove.ts",
      "text": "import { command, restPositionals, string } from 'cmd-ts';\nimport { removeFiles } from '../remove';\n\n/**\n * remove variable - Auto-generated expression\n * \n * ‚ö†Ô∏è WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const remove = command({\n  name: 'remove',\n\n  args: {\n    files: restPositionals({\n      description: 'The files to generate, relative to @bemedev/core/src',\n      displayName: 'Files',\n      type: string,\n    }),\n  },\n  handler: async ({ files }) => {\n    const isEmpty = files.length === 0;\n    if (isEmpty) return console.warn('No files specified for removal.');\n    return removeFiles(...files);\n  },\n});\n\n    "
    }
  }
}